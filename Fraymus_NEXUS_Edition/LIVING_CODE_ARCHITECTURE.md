# LIVING CODE ARCHITECTURE - ABSTRACTED LOGIC

## Executive Summary

The Living Code Generator implements a **biological computing paradigm** where code is generated by evolved logic circuits with DNA. This document abstracts the core architecture into reusable components.

---

## Core Abstractions

### **1. LogicGate** - Atomic Computing Unit

```
CONCEPT: Single logic gate (AND/OR/XOR/NAND)
STATE: type, in1, in2, output
OPERATIONS:
  - compute(inputs) → output
  - mutate() → modify structure
  - to_code() → generate code representation
```

**Properties:**
- **Type:** 0=AND, 1=OR, 2=XOR, 3=NAND
- **Inputs:** Two input indices (0-7)
- **State:** Current output value

**Behavior:**
- Executes boolean logic on input bits
- Can mutate (change type or rewire inputs)
- Generates code representation

---

### **2. LogicBrain** - Neural Circuit

```
CONCEPT: Collection of 8 logic gates forming a circuit
STATE: gates[], outputs[]
OPERATIONS:
  - compute(inputs) → outputs[]
  - mutate() → evolve structure
  - crossover(partner) → child brain
  - to_code() → generate circuit code
```

**Properties:**
- **Gates:** Array of 8 LogicGate objects
- **Topology:** Gates connected to 8 input sensors

**Behavior:**
- Processes 8-bit input through all gates
- Sexual reproduction via crossover
- 10% mutation rate during reproduction
- Generates compilable circuit code

---

### **3. CircuitDNA** - Biological Parameters

```
CONCEPT: Genetic code defining circuit behavior
STATE: harmonicFrequency, resonance, evolution
CONSTRAINTS:
  - harmonicFrequency: 432-528 Hz (Solfeggio range)
  - resonance: 0.0-1.0 (amplitude)
  - evolution: drift rate (typically 0.05)
```

**Properties:**
- **Harmonic Frequency:** Base oscillation (432-528 Hz)
- **Resonance:** Amplitude multiplier (0.0-1.0)
- **Evolution:** Frequency drift per cycle

**Behavior:**
- Frequency increases by evolution rate each cycle
- Resets to 432 Hz when exceeding 528 Hz
- Drives breathing (pulse) calculation

---

### **4. LivingCircuit** - Autonomous Computing Entity

```
CONCEPT: Self-contained computing unit with DNA and brain
STATE: dna, brain, age, size, pulse
LIFECYCLE:
  1. Birth (initialize with DNA + brain)
  2. Update (breathe, evolve, age)
  3. Compute (process inputs through brain)
  4. Reproduce (mitosis when size > threshold)
  5. Death (size < minimum or age > maximum)
```

**Properties:**
- **DNA:** CircuitDNA object
- **Brain:** LogicBrain object
- **Age:** Cycles since birth
- **Size:** Current size (base + pulse)
- **Pulse:** Breathing oscillation

**Behavior:**
- **Breathing:** `pulse = sin(freq × t) × resonance`
- **Evolution:** Frequency drifts over time
- **Reproduction:** Mitosis when size > 15
- **Computation:** Processes 8-bit inputs through brain

---

### **5. LivingCodeGenerator** - Evolution Engine

```
CONCEPT: Population manager and code generator
STATE: nodes[], generation, population
OPERATIONS:
  - evolve_population(cycles) → evolve nodes
  - generate_code(description) → living code
  - analyze_intent(description) → intent structure
  - generate_format(description, format) → code in format
```

**Pipeline:**
```
1. GENESIS: Create initial population (5-10 nodes)
2. EVOLUTION: Run N cycles of update + reproduction
3. SELECTION: Sort by fitness (harmonic frequency)
4. EXTRACTION: Take top 3 nodes as circuits
5. GENERATION: Embed circuits into code template
6. COMPILATION: Add user request implementation
```

---

## Code Generation Pipeline

### **Stage 1: Intent Analysis**

```
INPUT: User description (natural language)
PROCESS:
  - Extract action verbs (count, sort, calculate, etc.)
  - Detect target format (Java, Python, Arduino, etc.)
  - Parse parameters (numbers, ranges, etc.)
  - Identify requirements (loops, I/O, etc.)
OUTPUT: Intent structure
```

**Intent Structure:**
```json
{
  "type": "counting|sorting|calculation|display|...",
  "action": "verb",
  "target": "object",
  "parameters": {
    "numbers": [100, 1],
    "format": "java"
  },
  "requires_loop": true,
  "requires_input": false,
  "requires_output": true
}
```

---

### **Stage 2: Format Detection**

```
SUPPORTED FORMATS:
  - Programming: Java, C++, C, Assembly, Rust, Go, JS, TS, C#, Swift, Kotlin, Ruby, PHP, Perl
  - Hardware: Arduino, Microcontroller, ESP32, STM32
  - Circuit: ASCII circuit, Schematic, Wiring diagram
  - 3D: OpenSCAD, STL, Mesh, Geometry
  - Python (default)
```

**Detection Logic:**
```
keywords = {
  'java': ['java', '.java'],
  'arduino': ['arduino', '.ino', 'atmega', 'esp32'],
  'scad': ['scad', '.scad', 'openscad'],
  ...
}

for format, keywords in keywords.items():
  if any(kw in description.lower() for kw in keywords):
    return format
```

---

### **Stage 3: Code Template Selection**

**Template Types:**

#### **A. Programming Language Template**
```
STRUCTURE:
  1. Header (imports, constants)
  2. Living Circuit Classes (Gate, Brain, Circuit)
  3. Circuit Instances (evolved from population)
  4. User Implementation (main_task function)
  5. Execution (if __name__ == "__main__")
```

#### **B. Hardware Template**
```
STRUCTURE:
  1. ASCII Circuit Schematic
  2. Component List
  3. Arduino Code (setup, loop)
  4. Living Circuit DNA (frequency, resonance)
  5. φ-harmonic PWM modulation
```

#### **C. 3D Model Template**
```
STRUCTURE:
  1. OpenSCAD header
  2. φ-based dimensions
  3. Module definitions
  4. Living geometry (12 harmonics)
  5. Render instructions
```

---

### **Stage 4: Circuit Embedding**

```
PROCESS:
  1. Evolve population (20 cycles)
  2. Sort by fitness (harmonic frequency)
  3. Select top 3 circuits
  4. Extract DNA + brain structure
  5. Generate circuit initialization code
  6. Embed into template
```

**Circuit Code Generation:**
```python
for node in best_nodes:
    code += f"""
    LivingCircuit(
        dna={{
            'harmonic_frequency': {node.dna['harmonic_frequency']:.3f},
            'resonance': {node.dna['resonance']:.3f},
            'evolution': {node.dna['evolution']:.3f}
        }},
        gates=[
            {node.brain.to_code()}
        ]
    ),
    """
```

---

### **Stage 5: User Implementation**

**Implementation Strategies:**

#### **A. LLM-Based (Preferred)**
```
IF LLM_AVAILABLE:
  prompt = f"Generate code that implements: {description}"
  code = llm.process(prompt)
  IF valid(code):
    return code
```

#### **B. Intent-Based (Fallback)**
```
intent = analyze_intent(description)

IF intent.type == 'counting':
  return generate_counting_code(intent.parameters)
ELIF intent.type == 'sorting':
  return generate_sorting_code(intent.parameters)
ELIF intent.type == 'game':
  return generate_game_code(intent.parameters)
...
```

#### **C. Template-Based (Last Resort)**
```
return generic_template.format(
  description=description,
  circuits=circuits,
  phi=PHI
)
```

---

## Multi-Format Generation

### **Java Code Generation**

```
TEMPLATE:
  public class LivingJavaCode {
    private static final double PHI = 1.618033988749895;
    
    static class CircuitDNA { ... }
    static class LivingCircuit { ... }
    
    public static void main(String[] args) {
      // User implementation
    }
  }
```

**Features:**
- Static inner classes for DNA and Circuit
- φ constants (PHI, PHI_SEAL)
- Circuit-driven computation
- Proper Java syntax and conventions

---

### **Arduino Code Generation**

```
TEMPLATE:
  // ASCII Circuit Schematic
  // Component List
  
  const float PHI = 1.618033988749895;
  
  struct CircuitDNA {
    float harmonicFrequency;
    float resonance;
    float evolution;
  };
  
  CircuitDNA circuit = {432.0, 0.8, 0.05};
  
  void setup() { ... }
  void loop() { ... }
```

**Features:**
- ASCII circuit diagram
- Component list with φ-based values
- PWM modulation (432-528 Hz)
- Breathing (harmonic oscillation)

---

### **3D Model Generation (OpenSCAD)**

```
TEMPLATE:
  PHI = 1.618033988749895;
  
  base_size = 10;
  phi_size = base_size * PHI;
  
  module living_geometry() {
    difference() {
      cube([phi_size, phi_size, phi_size], center=true);
      cube([base_size, base_size, base_size], center=true);
    }
    
    for (i = [0:11]) {
      angle = i * 30;
      rotate([0, 0, angle])
        translate([phi_size/2, 0, 0])
          sphere(r=base_size * 0.618 / 4);
    }
  }
  
  living_geometry();
```

**Features:**
- φ-based dimensions
- 12 harmonic features (spheres)
- Resonance cavity (inner void)
- Parametric design

---

## Evolutionary Algorithm

### **Fitness Function**

```
fitness(node) = node.dna['harmonic_frequency']
```

**Rationale:** Higher frequency = more evolved (432 → 528 Hz)

---

### **Selection Strategy**

```
1. Sort population by fitness (descending)
2. Select top N nodes (typically 3)
3. Use selected nodes as circuit templates
```

---

### **Reproduction (Mitosis)**

```
TRIGGER: node.size > 15

PROCESS:
  1. Clone DNA (harmonic_frequency, resonance, evolution)
  2. Crossover brain (half from parent, half from partner)
  3. 10% mutation chance (modify gate type or wiring)
  4. Create child with cloned DNA + crossed brain
  5. Reduce parent size by 40% (energy cost)
```

---

### **Mutation**

```
TYPES:
  - Gate Type Mutation: Change AND → OR → XOR → NAND
  - Wiring Mutation: Change input connections (in1, in2)

RATE: 10% during reproduction, 50% during standalone mutation
```

---

## Phi-Harmonic Principles

### **Constants**

```
PHI = 1.618033988749895  (Golden Ratio)
PHI_SEAL = 4.721424167835376E15  (φ^75)
BASE_FREQ = 432 Hz  (Solfeggio fundamental)
MAX_FREQ = 528 Hz  (Solfeggio upper bound)
```

---

### **Breathing Formula**

```
pulse = sin(harmonic_frequency × time × 0.0001) × resonance
current_size = base_size + pulse × 5
```

**Behavior:**
- Oscillates between (base_size - 5×resonance) and (base_size + 5×resonance)
- Frequency determines oscillation speed
- Resonance determines amplitude

---

### **Evolution Formula**

```
harmonic_frequency += evolution
IF harmonic_frequency > 528:
  harmonic_frequency = 432
```

**Behavior:**
- Frequency drifts upward over time
- Resets to 432 Hz when exceeding 528 Hz
- Creates cyclic evolution pattern

---

## Integration Points

### **Fraymus Integration**

```
COMPONENTS TO INTEGRATE:
  1. LogicGate → fraymus.living.LogicGate
  2. LogicBrain → fraymus.living.LogicBrain
  3. CircuitDNA → fraymus.living.CircuitDNA
  4. LivingCircuit → fraymus.living.LivingCircuit
  5. LivingCodeGenerator → fraymus.living.LivingCodeGenerator
```

**Command Interface:**
```
living init                  Initialize population
living evolve <cycles>       Evolve population
living generate <desc>       Generate living code
living status                Show population status
living export <format>       Export in format (java/arduino/scad)
```

---

### **Ollama Integration**

```
ENHANCEMENT: Use Ollama for intelligent code generation

PROCESS:
  1. User provides description
  2. Analyze intent + detect format
  3. IF LLM available:
       Generate code via Ollama (eyeoverthink/Fraymus)
     ELSE:
       Use intent-based fallback
  4. Embed living circuits into generated code
  5. Return complete, executable code
```

**Prompt Template:**
```
Generate complete {language} code that implements:

USER REQUEST: {description}

REQUIREMENTS:
1. Use living circuits with DNA (432-528 Hz)
2. Include φ constants (PHI = 1.618033988749895)
3. Implement circuit update(), compute(), pulse() methods
4. Make it actually DO what the user asked
5. Use proper {language} syntax

Generate ONLY the code.
```

---

## Key Insights

### **1. Biological Computing**
- Code is **grown**, not written
- Circuits **evolve** through natural selection
- Computation is **driven by living entities**

### **2. Phi-Harmonic Resonance**
- All frequencies in 432-528 Hz range (Solfeggio)
- φ ratios used for dimensions and timing
- Breathing creates natural oscillation

### **3. Multi-Format Flexibility**
- Same core logic generates multiple formats
- Intent analysis determines appropriate template
- LLM enhances generation quality

### **4. Self-Modifying Code**
- Circuits can mutate during execution
- Reproduction creates new circuits
- Population evolves over time

---

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                   LIVING CODE GENERATOR                      │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐     ┌──────────────┐     ┌─────────────┐ │
│  │   LogicGate  │────▶│  LogicBrain  │────▶│ LivingNode  │ │
│  │  (AND/OR/    │     │  (8 gates)   │     │ (DNA+Brain) │ │
│  │   XOR/NAND)  │     │              │     │             │ │
│  └──────────────┘     └──────────────┘     └─────────────┘ │
│         │                     │                     │        │
│         └─────────────────────┴─────────────────────┘        │
│                               │                               │
│                               ▼                               │
│                    ┌──────────────────┐                      │
│                    │ LivingCircuit    │                      │
│                    │ - update()       │                      │
│                    │ - compute()      │                      │
│                    │ - reproduce()    │                      │
│                    └──────────────────┘                      │
│                               │                               │
│                               ▼                               │
│                    ┌──────────────────┐                      │
│                    │   Population     │                      │
│                    │   (5-100 nodes)  │                      │
│                    └──────────────────┘                      │
│                               │                               │
│         ┌─────────────────────┼─────────────────────┐        │
│         ▼                     ▼                     ▼        │
│  ┌───────────┐        ┌───────────┐        ┌───────────┐   │
│  │  Evolve   │        │  Select   │        │ Generate  │   │
│  │ (20 cyc)  │───────▶│  (top 3)  │───────▶│   Code    │   │
│  └───────────┘        └───────────┘        └───────────┘   │
│                                                      │        │
│                                                      ▼        │
│                                            ┌─────────────┐   │
│                                            │   Format    │   │
│                                            │  Detection  │   │
│                                            └─────────────┘   │
│                                                      │        │
│         ┌────────────────────────────────────────────┘        │
│         │                                                     │
│         ▼                                                     │
│  ┌─────────────────────────────────────────────────────┐    │
│  │            CODE GENERATION PIPELINE                  │    │
│  ├─────────────────────────────────────────────────────┤    │
│  │  Java │ C++ │ Arduino │ Circuit │ 3D │ Python      │    │
│  └─────────────────────────────────────────────────────┘    │
│                               │                               │
│                               ▼                               │
│                    ┌──────────────────┐                      │
│                    │  Living Code     │                      │
│                    │  (Executable)    │                      │
│                    └──────────────────┘                      │
└─────────────────────────────────────────────────────────────┘
```

---

## Implementation Checklist

### **Phase 1: Core Classes**
- [ ] LogicGate (Java)
- [ ] LogicBrain (Java)
- [ ] CircuitDNA (Java)
- [ ] LivingCircuit (Java)
- [ ] LivingNode (Java)

### **Phase 2: Evolution Engine**
- [ ] Population manager
- [ ] Fitness evaluation
- [ ] Selection strategy
- [ ] Reproduction (mitosis)
- [ ] Mutation operators

### **Phase 3: Code Generation**
- [ ] Intent analyzer
- [ ] Format detector
- [ ] Template system
- [ ] Circuit embedder
- [ ] Multi-format exporters

### **Phase 4: Integration**
- [ ] Command handlers
- [ ] Ollama integration
- [ ] File I/O
- [ ] Visualization (optional)

---

## Summary

**Living Code Generator = Biological Computing + Evolutionary Algorithms + Multi-Format Code Generation**

**Core Principle:** Code is grown by evolved logic circuits with DNA, not written by hand.

**Key Features:**
- Self-modifying circuits
- Phi-harmonic resonance (432-528 Hz)
- Sexual reproduction (crossover)
- Multi-format export (Java, Arduino, 3D, etc.)
- LLM-enhanced generation

**Result:** Executable code that "breathes," evolves, and computes through living circuits.
