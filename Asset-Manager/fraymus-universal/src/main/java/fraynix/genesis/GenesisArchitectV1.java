package fraynix.genesis;

import fraynix.core.*;
import fraynix.fs.FrayFS;
import fraynix.observe.EventLogger;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.security.MessageDigest;
import java.util.*;

/**
 * GENESIS ARCHITECT V1: Safe code creation.
 * 
 * Genesis starts as templated generation + optional "creative mutation" behind flags.
 * 
 * Blueprint = modules + dependencies + entrypoints + tests
 * ConstructionSwarm builds in a sandbox dir
 * 
 * Output is signed:
 *   - artifact.jar (or source files)
 *   - manifest.json
 *   - hash.sig (HMAC signature)
 * 
 * Safety: Genesis may only write into /sys/apps/<name>/
 * Never overwrite core OS packages unless explicitly allowed.
 */
public class GenesisArchitectV1 implements KernelService {

    private final FrayFS fs;
    private final EventLogger logger;
    private final CapabilityToken capabilities;
    
    private final Path outputRoot;
    private final byte[] signingKey;
    
    private volatile boolean running = false;
    private long startTime;
    
    // Stats
    private int blueprintsCreated = 0;
    private int artifactsBuilt = 0;
    private int buildsFailed = 0;

    // Templates
    private final Map<String, String> templates = new HashMap<>();

    public GenesisArchitectV1(FrayFS fs, EventLogger logger) {
        this(fs, logger, Path.of("sys", "apps"));
    }

    public GenesisArchitectV1(FrayFS fs, EventLogger logger, Path outputRoot) {
        this.fs = fs;
        this.logger = logger;
        this.outputRoot = outputRoot;
        this.capabilities = CapabilityToken.genesis("GenesisArchitect");
        this.signingKey = generateSigningKey();
        
        initTemplates();
        
        System.out.println("⚡ GenesisArchitect V1 initialized (output: " + outputRoot + ")");
    }

    private byte[] generateSigningKey() {
        // In production, this would be loaded from secure storage
        return "fraynix-genesis-v1-signing-key".getBytes(StandardCharsets.UTF_8);
    }

    private void initTemplates() {
        // Java class template
        templates.put("java-class", """
            package ${package};
            
            /**
             * ${description}
             * Generated by Genesis Architect V1
             */
            public class ${className} {
                
                public ${className}() {
                    // Initialize
                }
                
                public static void main(String[] args) {
                    System.out.println("${className} started");
                }
            }
            """);
        
        // REST API template
        templates.put("rest-api", """
            package ${package};
            
            import java.io.*;
            import java.net.*;
            import com.sun.net.httpserver.*;
            
            /**
             * ${description}
             * Generated by Genesis Architect V1
             */
            public class ${className} {
                
                private final HttpServer server;
                
                public ${className}(int port) throws IOException {
                    server = HttpServer.create(new InetSocketAddress(port), 0);
                    setupRoutes();
                }
                
                private void setupRoutes() {
                    server.createContext("/health", this::handleHealth);
                    server.createContext("/api", this::handleApi);
                }
                
                private void handleHealth(HttpExchange exchange) throws IOException {
                    String response = "{\\"status\\":\\"ok\\"}";
                    exchange.sendResponseHeaders(200, response.length());
                    try (OutputStream os = exchange.getResponseBody()) {
                        os.write(response.getBytes());
                    }
                }
                
                private void handleApi(HttpExchange exchange) throws IOException {
                    String response = "{\\"message\\":\\"Hello from Genesis\\"}";
                    exchange.sendResponseHeaders(200, response.length());
                    try (OutputStream os = exchange.getResponseBody()) {
                        os.write(response.getBytes());
                    }
                }
                
                public void start() {
                    server.start();
                    System.out.println("Server started on port " + server.getAddress().getPort());
                }
                
                public static void main(String[] args) throws IOException {
                    int port = args.length > 0 ? Integer.parseInt(args[0]) : 8080;
                    new ${className}(port).start();
                }
            }
            """);
        
        // Config template
        templates.put("config-json", """
            {
                "name": "${name}",
                "version": "1.0.0",
                "generated": "${timestamp}",
                "generator": "Genesis Architect V1",
                "config": {
                    ${config}
                }
            }
            """);
        
        // Test template
        templates.put("test-java", """
            package ${package};
            
            /**
             * Tests for ${targetClass}
             * Generated by Genesis Architect V1
             */
            public class ${className}Test {
                
                public static void main(String[] args) {
                    ${className}Test test = new ${className}Test();
                    test.runAll();
                }
                
                public void runAll() {
                    int passed = 0;
                    int failed = 0;
                    
                    try { testBasic(); passed++; } catch (Exception e) { failed++; System.err.println("testBasic FAILED: " + e); }
                    try { testEdgeCases(); passed++; } catch (Exception e) { failed++; System.err.println("testEdgeCases FAILED: " + e); }
                    
                    System.out.println("Tests: " + passed + " passed, " + failed + " failed");
                }
                
                public void testBasic() {
                    // Basic functionality test
                    assert true : "Basic test should pass";
                }
                
                public void testEdgeCases() {
                    // Edge case tests
                    assert true : "Edge case test should pass";
                }
            }
            """);
        
        // README template
        templates.put("readme", """
            # ${name}
            
            ${description}
            
            ## Generated by Genesis Architect V1
            
            **Intent:** ${intent}
            **Created:** ${timestamp}
            
            ## Structure
            
            ${structure}
            
            ## Usage
            
            ```bash
            java -jar ${name}.jar
            ```
            
            ## License
            
            Generated code - use as needed.
            """);
    }

    public Blueprint designBlueprint(String intent) {
        blueprintsCreated++;
        
        Blueprint blueprint = new Blueprint(intent);
        String safeName = sanitizeName(intent);
        
        // Analyze intent and create appropriate modules
        if (containsAny(intent, "api", "rest", "server", "http")) {
            blueprint.addModule(new Blueprint.Module(
                safeName + "Server",
                Blueprint.ModuleType.BACKEND,
                "java",
                safeName + "/src/main/java/" + safeName + "/" + capitalize(safeName) + "Server.java"
            ));
            blueprint.addEntrypoint(safeName + "Server");
        }
        
        if (containsAny(intent, "database", "db", "storage", "persist")) {
            blueprint.addModule(new Blueprint.Module(
                safeName + "Repository",
                Blueprint.ModuleType.DATABASE,
                "java",
                safeName + "/src/main/java/" + safeName + "/" + capitalize(safeName) + "Repository.java"
            ));
        }
        
        // Always add config
        blueprint.addModule(new Blueprint.Module(
            "config",
            Blueprint.ModuleType.CONFIG,
            "json",
            safeName + "/config.json"
        ));
        
        // Always add tests
        blueprint.addModule(new Blueprint.Module(
            safeName + "Test",
            Blueprint.ModuleType.TEST,
            "java",
            safeName + "/src/test/java/" + safeName + "/" + capitalize(safeName) + "Test.java"
        ));
        blueprint.addTest(safeName + "Test");
        
        // Always add README
        blueprint.addModule(new Blueprint.Module(
            "README",
            Blueprint.ModuleType.DOCS,
            "markdown",
            safeName + "/README.md"
        ));
        
        // If no specific modules detected, add a basic main class
        if (blueprint.getModules().size() <= 3) {
            blueprint.addModule(new Blueprint.Module(
                safeName + "Main",
                Blueprint.ModuleType.BACKEND,
                "java",
                safeName + "/src/main/java/" + safeName + "/" + capitalize(safeName) + "Main.java"
            ));
            blueprint.addEntrypoint(safeName + "Main");
        }
        
        blueprint.setMetadata("generator", "GenesisArchitectV1");
        blueprint.setMetadata("timestamp", java.time.Instant.now().toString());
        
        logger.logEvent("blueprint_created", Map.of(
            "id", blueprint.getId(),
            "intent", intent,
            "modules", blueprint.getModules().size()
        ));
        
        return blueprint;
    }

    public List<Artifact> build(Blueprint blueprint) {
        if (!blueprint.isValid()) {
            logger.logEvent("build_failed", Map.of(
                "blueprintId", blueprint.getId(),
                "reason", "Invalid blueprint"
            ));
            buildsFailed++;
            return List.of();
        }
        
        List<Artifact> artifacts = new ArrayList<>();
        String projectName = sanitizeName(blueprint.getIntent());
        Path projectPath = outputRoot.resolve(projectName);
        
        try {
            // Create project directory
            Files.createDirectories(projectPath);
            
            // Generate each module
            for (Blueprint.Module module : blueprint.getModules()) {
                Artifact artifact = generateModule(blueprint, module, projectPath);
                if (artifact != null) {
                    artifacts.add(artifact);
                    artifactsBuilt++;
                }
            }
            
            // Generate manifest
            Artifact manifest = generateManifest(blueprint, projectPath, artifacts);
            artifacts.add(manifest);
            
            // Generate signatures
            for (Artifact artifact : artifacts) {
                signArtifact(artifact);
            }
            
            logger.logEvent("build_completed", Map.of(
                "blueprintId", blueprint.getId(),
                "artifacts", artifacts.size(),
                "path", projectPath.toString()
            ));
            
        } catch (Exception e) {
            buildsFailed++;
            logger.logEvent("build_failed", Map.of(
                "blueprintId", blueprint.getId(),
                "error", e.getMessage()
            ));
        }
        
        return artifacts;
    }

    private Artifact generateModule(Blueprint blueprint, Blueprint.Module module, Path projectPath) {
        try {
            Path modulePath = projectPath.resolve(module.filePath());
            Files.createDirectories(modulePath.getParent());
            
            String content = generateContent(blueprint, module);
            Files.writeString(modulePath, content);
            
            // Also write to virtual FS
            fs.write("/sys/apps/" + modulePath.toString().replace('\\', '/'), 
                    content.getBytes(StandardCharsets.UTF_8));
            
            String hash = computeHash(content.getBytes(StandardCharsets.UTF_8));
            
            Artifact artifact = Artifact.builder()
                .name(module.name())
                .type(mapModuleType(module.type()))
                .path(modulePath)
                .hash(hash)
                .sizeBytes(content.length())
                .blueprintId(blueprint.getId())
                .status(Artifact.ArtifactStatus.BUILT)
                .build();
            
            logger.logArtifactCreated(artifact.id(), artifact.name(), 
                artifact.type().name(), hash.substring(0, 8));
            
            return artifact;
            
        } catch (Exception e) {
            logger.logEvent("module_generation_failed", Map.of(
                "module", module.name(),
                "error", e.getMessage()
            ));
            return null;
        }
    }

    private String generateContent(Blueprint blueprint, Blueprint.Module module) {
        String safeName = sanitizeName(blueprint.getIntent());
        String className = capitalize(safeName);
        
        return switch (module.type()) {
            case BACKEND -> {
                String template = module.name().contains("Server") ? 
                    templates.get("rest-api") : templates.get("java-class");
                yield template
                    .replace("${package}", safeName)
                    .replace("${className}", module.name())
                    .replace("${description}", "Module: " + module.name() + " for " + blueprint.getIntent());
            }
            case DATABASE -> templates.get("java-class")
                .replace("${package}", safeName)
                .replace("${className}", module.name())
                .replace("${description}", "Repository for " + blueprint.getIntent());
            case CONFIG -> templates.get("config-json")
                .replace("${name}", safeName)
                .replace("${timestamp}", java.time.Instant.now().toString())
                .replace("${config}", "\"generated\": true");
            case TEST -> templates.get("test-java")
                .replace("${package}", safeName)
                .replace("${className}", className)
                .replace("${targetClass}", className);
            case DOCS -> templates.get("readme")
                .replace("${name}", className)
                .replace("${description}", blueprint.getIntent())
                .replace("${intent}", blueprint.getIntent())
                .replace("${timestamp}", java.time.Instant.now().toString())
                .replace("${structure}", blueprint.getModules().stream()
                    .map(m -> "- " + m.filePath())
                    .reduce((a, b) -> a + "\n" + b)
                    .orElse(""));
            default -> "// Generated by Genesis Architect V1\n// Module: " + module.name();
        };
    }

    private Artifact generateManifest(Blueprint blueprint, Path projectPath, List<Artifact> artifacts) 
            throws IOException {
        
        Map<String, Object> manifest = new LinkedHashMap<>();
        manifest.put("blueprintId", blueprint.getId());
        manifest.put("intent", blueprint.getIntent());
        manifest.put("timestamp", blueprint.getTimestamp());
        manifest.put("generator", "GenesisArchitectV1");
        manifest.put("artifacts", artifacts.stream()
            .map(a -> Map.of(
                "name", a.name(),
                "type", a.type().name(),
                "hash", a.hash(),
                "path", a.path().toString()
            ))
            .toList());
        
        String manifestJson = toJson(manifest);
        Path manifestPath = projectPath.resolve("manifest.json");
        Files.writeString(manifestPath, manifestJson);
        
        return Artifact.builder()
            .name("manifest")
            .type(Artifact.ArtifactType.MANIFEST)
            .path(manifestPath)
            .hash(computeHash(manifestJson.getBytes(StandardCharsets.UTF_8)))
            .sizeBytes(manifestJson.length())
            .blueprintId(blueprint.getId())
            .status(Artifact.ArtifactStatus.BUILT)
            .build();
    }

    private void signArtifact(Artifact artifact) {
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(new SecretKeySpec(signingKey, "HmacSHA256"));
            byte[] signature = mac.doFinal(artifact.hash().getBytes(StandardCharsets.UTF_8));
            
            String sigHex = bytesToHex(signature);
            
            // Write signature file
            Path sigPath = artifact.path().resolveSibling(artifact.path().getFileName() + ".sig");
            Files.writeString(sigPath, sigHex);
            
        } catch (Exception e) {
            logger.logEvent("signing_failed", Map.of(
                "artifact", artifact.name(),
                "error", e.getMessage()
            ));
        }
    }

    public boolean verifyArtifact(Artifact artifact) {
        try {
            // Verify hash
            byte[] content = Files.readAllBytes(artifact.path());
            String computedHash = computeHash(content);
            
            if (!computedHash.equals(artifact.hash())) {
                return false;
            }
            
            // Verify signature
            Path sigPath = artifact.path().resolveSibling(artifact.path().getFileName() + ".sig");
            if (Files.exists(sigPath)) {
                String storedSig = Files.readString(sigPath).trim();
                
                Mac mac = Mac.getInstance("HmacSHA256");
                mac.init(new SecretKeySpec(signingKey, "HmacSHA256"));
                byte[] expectedSig = mac.doFinal(artifact.hash().getBytes(StandardCharsets.UTF_8));
                
                return storedSig.equals(bytesToHex(expectedSig));
            }
            
            return true; // No signature file, just verify hash
            
        } catch (Exception e) {
            return false;
        }
    }

    // Utility methods
    private String sanitizeName(String intent) {
        if (intent == null) {
            return "app";
        }
        String cleaned = intent.toLowerCase()
            .replaceAll("[^a-z0-9]+", "_")
            .replaceAll("^_+|_+$", "")
            .trim();
        if (cleaned.isEmpty()) {
            cleaned = "app";
        }
        return cleaned.substring(0, Math.min(30, cleaned.length()));
    }

    private String capitalize(String s) {
        if (s == null || s.isEmpty()) return s;
        return Character.toUpperCase(s.charAt(0)) + s.substring(1);
    }

    private boolean containsAny(String text, String... keywords) {
        String lower = text.toLowerCase();
        for (String kw : keywords) {
            if (lower.contains(kw)) return true;
        }
        return false;
    }

    private String computeHash(byte[] data) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            return bytesToHex(md.digest(data));
        } catch (Exception e) {
            return "error";
        }
    }

    private String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }

    private Artifact.ArtifactType mapModuleType(Blueprint.ModuleType type) {
        return switch (type) {
            case BACKEND, FRONTEND, LIBRARY -> Artifact.ArtifactType.SOURCE;
            case DATABASE -> Artifact.ArtifactType.SOURCE;
            case CONFIG -> Artifact.ArtifactType.CONFIG;
            case TEST -> Artifact.ArtifactType.TEST;
            case DOCS -> Artifact.ArtifactType.DOCS;
            case SCRIPT -> Artifact.ArtifactType.SCRIPT;
        };
    }

    private String toJson(Map<String, Object> map) {
        StringBuilder sb = new StringBuilder("{\n");
        boolean first = true;
        for (Map.Entry<String, Object> e : map.entrySet()) {
            if (!first) sb.append(",\n");
            first = false;
            sb.append("  \"").append(e.getKey()).append("\": ");
            Object v = e.getValue();
            if (v instanceof String) {
                sb.append("\"").append(v).append("\"");
            } else if (v instanceof List) {
                sb.append(listToJson((List<?>) v));
            } else {
                sb.append(v);
            }
        }
        sb.append("\n}");
        return sb.toString();
    }

    private String listToJson(List<?> list) {
        StringBuilder sb = new StringBuilder("[\n");
        boolean first = true;
        for (Object item : list) {
            if (!first) sb.append(",\n");
            first = false;
            if (item instanceof Map) {
                sb.append("    ").append(toJson((Map<String, Object>) item).replace("\n", "\n    "));
            } else {
                sb.append("    \"").append(item).append("\"");
            }
        }
        sb.append("\n  ]");
        return sb.toString();
    }

    // KernelService implementation
    @Override
    public String getName() { return "GenesisArchitect"; }
    
    @Override
    public String getVersion() { return "1.0.0"; }

    @Override
    public void start() {
        running = true;
        startTime = System.currentTimeMillis();
        System.out.println("⚡ GenesisArchitect started");
    }

    @Override
    public void stop() {
        running = false;
        System.out.println("⚡ GenesisArchitect stopped");
    }

    @Override
    public void restart() { stop(); start(); }

    @Override
    public ServiceStatus getStatus() {
        return running ? ServiceStatus.RUNNING : ServiceStatus.STOPPED;
    }

    @Override
    public HealthReport getHealth() {
        long uptime = running ? System.currentTimeMillis() - startTime : 0;
        return HealthReport.healthy(getStatus(), uptime);
    }

    @Override
    public ServiceMetrics getMetrics() {
        return new ServiceMetrics(
            blueprintsCreated,
            artifactsBuilt,
            buildsFailed,
            0, 0, 0.0, 0,
            Map.of("templates", (long) templates.size())
        );
    }
}
