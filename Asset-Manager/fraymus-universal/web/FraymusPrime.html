<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FRAYMUS // PRIME INTERFACE</title>
    <style>
        :root {
            --neon-green: #0f0;
            --neon-blue: #00f3ff;
            --neon-red: #ff003c;
            --blue-team: #44aaff;
            --red-team: #ff4444;
            --purple-team: #d044ff;
            --bg-dark: #050505;
            --grid-color: rgba(0, 243, 255, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg-dark);
            color: var(--neon-blue);
            font-family: 'Courier New', monospace;
            margin: 0;
            overflow: hidden;
            display: grid;
            grid-template-columns: 22% 56% 22%;
            grid-template-rows: 7% 40% 48% 5%;
            height: 100vh;
            width: 100vw;
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 30px 30px;
        }

        .panel {
            border: 1px solid var(--neon-blue);
            background: rgba(0, 20, 40, 0.7);
            margin: 3px;
            padding: 8px;
            box-shadow: 0 0 8px rgba(0, 243, 255, 0.3);
            position: relative;
            overflow-y: auto;
        }

        .header {
            grid-column: 1 / 4;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--neon-green);
            overflow: hidden;
        }

        h1 { margin: 0; text-shadow: 0 0 10px var(--neon-green); color: var(--neon-green); font-size: 18px; }
        h3 { color: var(--neon-blue); margin: 4px 0; font-size: 11px; }
        p { margin: 3px 0; font-size: 10px; }
        hr { border-color: rgba(0, 243, 255, 0.2); margin: 5px 0; }
        
        .viewport {
            grid-column: 2;
            grid-row: 2;
            border-color: var(--neon-red);
        }

        .center-bottom {
            grid-column: 2;
            grid-row: 3;
            display: grid;
            grid-template-rows: auto auto auto 1fr auto;
            gap: 0;
        }

        .stats-left { grid-column: 1; grid-row: 2 / 4; }
        .stats-right { grid-column: 3; grid-row: 2 / 4; }

        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
        .blink { animation: blink 2s infinite; }

        .bar-container { width: 100%; background: #222; height: 8px; margin-bottom: 6px; }
        .bar-fill { height: 100%; background: var(--neon-green); width: 0%; transition: width 0.5s; }
        
        .ticker-tape {
            grid-column: 1 / 4; grid-row: 4;
            border-top: 2px solid var(--neon-red);
            display: flex; align-items: center; overflow: hidden;
            background: rgba(20, 0, 0, 0.9);
        }
        .ticker-content { display: flex; animation: scroll-left 40s linear infinite; white-space: nowrap; }
        @keyframes scroll-left { 0% { transform: translateX(100%); } 100% { transform: translateX(-100%); } }
        .ticker-item { padding: 0 20px; color: var(--neon-red); font-weight: bold; font-size: 11px; }
        .ticker-item.blue { color: var(--blue-team); }
        .ticker-item.red { color: var(--red-team); }
        .ticker-item.purple { color: var(--purple-team); }
        .ticker-item.green { color: var(--neon-green); text-shadow: 0 0 10px var(--neon-green); }

        /* CRT SCANLINES */
        body::after {
            content: " "; display: block; position: fixed;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.25) 50%), linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06));
            z-index: 2; background-size: 100% 2px, 3px 100%; pointer-events: none;
        }

        /* TEAM PANELS */
        .team-row {
            padding: 6px 8px;
            border-left: 3px solid #333;
            background: rgba(0,0,0,0.5);
            margin: 2px 0;
        }
        .team-row.blue-team { border-left-color: var(--blue-team); }
        .team-row.red-team { border-left-color: var(--red-team); }
        .team-row.purple-team { border-left-color: var(--purple-team); }
        .team-row h4 { font-size: 11px; margin: 0 0 4px 0; }
        .team-row.blue-team h4 { color: var(--blue-team); }
        .team-row.red-team h4 { color: var(--red-team); }
        .team-row.purple-team h4 { color: var(--purple-team); }

        .team-row .input-row { display: flex; gap: 4px; margin: 3px 0; }
        .team-row input {
            background: #111; border: 1px solid #333; color: #fff;
            padding: 4px 6px; font-family: monospace; font-size: 10px; flex: 1;
        }
        .team-row button {
            padding: 4px 10px; border: none; cursor: pointer; font-weight: bold;
            font-family: monospace; font-size: 10px; text-transform: uppercase;
        }
        .btn-blue { background: var(--blue-team); color: #000; }
        .btn-red { background: var(--red-team); color: #000; }
        .btn-purple { background: var(--purple-team); color: #000; }
        button:hover { filter: brightness(1.2); }

        .team-output {
            background: #000; padding: 4px 6px; border: 1px solid #222;
            font-size: 9px; color: #aaa; white-space: pre-wrap; min-height: 24px;
            max-height: 60px; overflow-y: auto;
        }
        .team-output.success { color: #4f4; border-color: #4f4; background: rgba(0,255,0,0.05); }

        /* TERMINAL */
        #console-log { font-size: 10px; color: var(--neon-green); overflow-y: auto; }
        #console-log div { padding: 1px 0; }
        .terminal-input { display: flex; gap: 4px; padding: 4px 0; }
        .terminal-input input {
            flex: 1; background: rgba(0,0,0,0.8); border: 1px solid var(--neon-green);
            color: var(--neon-green); padding: 5px 8px; font-family: monospace; font-size: 11px; outline: none;
        }
        .terminal-input input:focus { border-color: var(--neon-blue); box-shadow: 0 0 6px var(--neon-green); }

        .conn-indicator { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 4px; }
        .conn-on { background: var(--neon-green); box-shadow: 0 0 6px var(--neon-green); }
        .conn-off { background: var(--neon-red); box-shadow: 0 0 6px var(--neon-red); }

        .subsystem-row { display: flex; justify-content: space-between; font-size: 10px; padding: 1px 0; border-bottom: 1px solid rgba(0,243,255,0.07); }
        .subsystem-row .name { color: var(--neon-blue); }
        .subsystem-row .status-on { color: var(--neon-green); }
        .subsystem-row .status-off { color: #555; }

        canvas { image-rendering: pixelated; }

        .metrics-bar { display: flex; gap: 10px; font-size: 10px; color: #888; }
        .metrics-bar span { color: #4ecdc4; font-weight: bold; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <!-- ═══════════════════ HEADER ═══════════════════ -->
    <div class="panel header">
        <h1 style="padding-left: 12px;">FRAYMUS // PRIME</h1>
        <div class="metrics-bar" style="padding: 0 10px;">
            <div>EVO: <span id="m_evo">1.10</span></div>
            <div>ENTITIES: <span id="m_solved">0</span></div>
        </div>
        <div style="padding-right: 12px; font-size: 11px;">
            <span class="conn-indicator" id="conn-dot"></span>
            <span id="conn-status">OFFLINE</span> |
            <span>PHI: <span id="phi-val" style="color:var(--neon-green)">1.618033</span></span> |
            <span class="blink">SOVEREIGN</span>
        </div>
    </div>

    <!-- ═══════════════════ LEFT: BIO + SUBSYSTEMS ═══════════════════ -->
    <div class="panel stats-left">
        <h3>// BIO-LINK</h3>
        <p>HEART RATE:</p>
        <div style="color:var(--neon-red); font-size: 22px; font-weight: bold;" id="hr-display">72 BPM</div>
        <canvas id="heart-graph" width="200" height="50" style="width:100%; height:50px;"></canvas>
        <p>STRESS:</p>
        <div class="bar-container"><div id="stress-bar" class="bar-fill" style="width:10%; background:var(--neon-blue)"></div></div>
        <p>COGNITIVE SYNC:</p>
        <div class="bar-container"><div id="sync-bar" class="bar-fill" style="width:86%;"></div></div>
        <p>PHI RESONANCE:</p>
        <div class="bar-container"><div id="phi-bar" class="bar-fill" style="width:61.8%; background:gold;"></div></div>
        <hr>
        <h3>// ENTROPY VISUALIZER</h3>
        <canvas id="entropyCanvas" height="40" width="200" style="width:100%; height:40px; border:1px solid #333;"></canvas>
        <hr>
        <h3>// SUBSYSTEMS (20)</h3>
        <div id="subsystem-list"></div>
    </div>

    <!-- ═══════════════════ CENTER TOP: 3D VIEWPORT ═══════════════════ -->
    <div class="panel viewport" id="canvas-container">
        <div style="position:absolute; top:6px; left:8px; color:var(--neon-red); font-size:10px; z-index:1;">
            SOVEREIGN MESH // <span id="mesh-verts">42</span> VERTICES
        </div>
        <div style="position:absolute; bottom:6px; right:8px; color:var(--neon-blue); font-size:9px; z-index:1;">
            DEFORM: <span id="mesh-deform">0.0000</span> | SPEED: <span id="phys-speed">0.0000</span>
        </div>
    </div>

    <!-- ═══════════════════ CENTER BOTTOM: TEAMS + TERMINAL ═══════════════════ -->
    <div class="panel center-bottom">
        <!-- BLUE TEAM -->
        <div class="team-row blue-team">
            <h4>BLUE TEAM: IDENTITY BURNER</h4>
            <div class="input-row">
                <input type="text" id="blueUser" placeholder="Username" value="Admin">
                <input type="password" id="bluePass" placeholder="Password" value="SkyBlue">
                <button class="btn-blue" onclick="sys.generateLock()">GENERATE LOCK</button>
            </div>
            <div id="blueOut" class="team-output">_WAITING_FOR_IDENTITY</div>
        </div>
        <!-- RED TEAM -->
        <div class="team-row red-team">
            <h4>RED TEAM: QUANTUM BREAKER</h4>
            <div class="input-row">
                <input type="text" id="redInput" placeholder="Target Key (N)" readonly>
                <button class="btn-red" onclick="sys.breakLock()">EXECUTE BREACH</button>
            </div>
            <div id="redOut" class="team-output">_TARGET_NONE</div>
        </div>
        <!-- PURPLE TEAM -->
        <div class="team-row purple-team">
            <h4>PURPLE TEAM: ORIGIN VERIFICATION</h4>
            <div class="input-row">
                <input type="text" id="verifPrime" placeholder="Recovered Prime" readonly>
                <button class="btn-purple" onclick="sys.verifyMatch()">VERIFY MATCH</button>
            </div>
            <div id="purpleOut" class="team-output">_AWAITING_DATA</div>
        </div>
        <!-- TERMINAL -->
        <div id="console-log" style="flex:1; overflow-y:auto; padding:4px;">
            <div>> FRAYMUS PRIME INITIALIZING...</div>
        </div>
        <div class="terminal-input">
            <input id="cmd-input" placeholder="COMMAND THE SYSTEM..." autofocus />
        </div>
    </div>

    <!-- ═══════════════════ RIGHT: ENGINE STATUS ═══════════════════ -->
    <div class="panel stats-right">
        <h3>// PHYSICS (17D HDRB)</h3>
        <p>HYPER-SPEED: <span id="phys-speed2" style="color:var(--neon-green)">0.0000</span></p>
        <p>DATA MASS: <span id="phys-mass" style="color:var(--neon-blue)">0.00</span></p>
        <p>MESH: <span id="phys-mesh" style="color:var(--neon-green)">STABLE</span></p>
        <hr>
        <h3>// GOD CHIP (FVM)</h3>
        <p>REGS: 16 | RAM: 64KB</p>
        <p>ACC: <span id="fvm-acc" style="color:var(--neon-green)">0</span></p>
        <hr>
        <h3>// CHRONOS</h3>
        <p>TIMELINES: <span style="color:var(--neon-blue)">8</span></p>
        <p>GEN: <span id="chrono-gen" style="color:var(--neon-green)">0</span> | SCORE: <span id="chrono-score" style="color:gold">---</span></p>
        <hr>
        <h3>// HOLO GRAPH</h3>
        <p>FACTS: <span id="holo-facts" style="color:var(--neon-blue)">4</span></p>
        <p>LAST: <span id="holo-last" style="color:var(--neon-green)">---</span></p>
        <hr>
        <h3>// NETWORK</h3>
        <p>NODE: <span id="net-status" style="color:#555">OFFLINE</span></p>
        <p>PEERS: <span id="net-peers" style="color:var(--neon-blue)">0</span></p>
        <hr>
        <h3>// SOUL CRYSTAL</h3>
        <p>STATE: <span id="soul-state" style="color:var(--neon-green)">PRESERVED</span></p>
        <p>SAVE: <span id="soul-time" style="color:#555">---</span></p>
        <hr>
        <h3>// NEXUS</h3>
        <p>OS FACTORY: <span class="blink" style="color:var(--neon-green)">READY</span></p>
        <p>TIERS: <span style="color:var(--neon-blue)">7</span></p>
        <hr>
        <h3>// EVOLUTION</h3>
        <p>AUTONOMY: <span id="autonomy-val" style="color:var(--neon-green)">31%</span></p>
        <div class="bar-container"><div id="autonomy-bar" class="bar-fill" style="width:31%; background:var(--neon-green);"></div></div>
        <p>DNA STORAGE: <span style="color:var(--neon-blue)">215 PB</span></p>
    </div>

    <!-- ═══════════════════ TICKER ═══════════════════ -->
    <div class="panel ticker-tape">
        <div class="ticker-content" id="ticker-content">
            <span class="ticker-item green">FRAYMUS PRIME // SOVEREIGN SYSTEM</span>
            <span class="ticker-item blue">[BLUE] IDENTITY BURNER READY</span>
            <span class="ticker-item red">[RED] QUANTUM BREAKER ARMED</span>
            <span class="ticker-item purple">[PURPLE] ORIGIN VERIFIER STANDING BY</span>
            <span class="ticker-item green">[SYS] 65 FILES / 20 PACKAGES / 0 DEPS</span>
            <span class="ticker-item blue">[CRYPTO] PURE BIGINTEGER</span>
            <span class="ticker-item red">[PHYSICS] 17D HDRB ACTIVE</span>
            <span class="ticker-item purple">[CHRONOS] 8 PARALLEL FUTURES</span>
            <span class="ticker-item green">[NEXUS] QUINE-OS FACTORY</span>
        </div>
    </div>

<script>
// ═══════════════════════════════════════════════════════════════════
// SOVEREIGN SYSTEM (phase_V8 engine — REAL CRYPTO, NOT SIMULATION)
// ═══════════════════════════════════════════════════════════════════
class SovereignSystem {
    constructor() {
        this.state = {
            dnaA: null, dnaB: null,
            primeA: null, primeB: null,
            foundFactor: null,
            evolution: 1.10,
            solved: 0
        };
        this.entropyCanvas = document.getElementById('entropyCanvas');
        this.entropyCtx = this.entropyCanvas.getContext('2d');
        this.renderNoise();
    }

    // ══════════════════════════════════════
    // BLUE TEAM: IDENTITY BURNER
    // ══════════════════════════════════════
    async generateLock() {
        const u = document.getElementById('blueUser').value;
        const p = document.getElementById('bluePass').value;
        if (!u || !p) return;

        log("BLUE TEAM: Generating identity lock...", '#44aaff');
        systemState = 'DEFENSE';
        meshPulse(0x44aaff, 1.5);

        const dnaA = u + p.slice(0, p.length / 2) + "_A";
        const dnaB = u + p.slice(p.length / 2) + "_B";
        this.state.dnaA = dnaA;
        this.state.dnaB = dnaB;

        const p1 = await this.textToPrime(dnaA);
        const p2 = await this.textToPrime(dnaB);
        this.state.primeA = p1;
        this.state.primeB = p2;

        const N = p1 * p2;

        this.renderEntropy(u + p);
        document.getElementById('blueOut').innerText = `LOCKED.\nN: ${N}\n[DNA A]: "${dnaA}"\n[DNA B]: "${dnaB}"`;
        document.getElementById('redInput').value = N.toString();
        document.getElementById('redOut').innerText = "_TARGET_LOCKED";
        document.getElementById('purpleOut').innerText = "_AWAITING_BREACH";
        document.getElementById('purpleOut').className = "team-output";
        this.state.foundFactor = null;

        log("BLUE: Lock N = " + N.toString().substring(0, 30) + "...", '#44aaff');
        addTicker("[BLUE] LOCK GENERATED: " + N.toString().substring(0, 20) + "...", "blue");

        // Send to Java backend
        wsSend("BLUE_LOCK:" + N.toString());

        meshPulse(0x44aaff, 1.0);
        systemState = 'NEUTRAL';
    }

    // ══════════════════════════════════════
    // RED TEAM: QUANTUM BREAKER (Pollard's Rho)
    // ══════════════════════════════════════
    async breakLock() {
        const input = document.getElementById('redInput').value;
        if (!input) return;

        const display = document.getElementById('redOut');
        display.innerText = "TUNNELING... (Please Wait)";
        log("RED TEAM: Executing breach...", '#ff4444');
        systemState = 'DEFENSE';
        meshPulse(0xff4444, 2.0);
        stressLevel = 0.8;
        updateBioMetrics();

        await new Promise(r => setTimeout(r, 50));

        const N = BigInt(input);
        const start = performance.now();
        const factor = await this.pollardsRho(N);
        const time = (performance.now() - start).toFixed(2);

        if (factor) {
            this.state.foundFactor = factor;
            display.innerHTML = `BREACH (${time}ms)\nFACTOR: ${factor}`;
            document.getElementById('verifPrime').value = factor.toString();

            this.state.solved++;
            this.state.evolution += 0.1;
            this.updateMetrics();

            log("RED: BREACH in " + time + "ms. Factor: " + factor.toString().substring(0, 20) + "...", '#ff4444');
            addTicker("[RED] BREACH " + time + "ms", "red");
            wsSend("RED_BREACH:" + factor.toString() + ":" + time);

            meshDeformation = 0.3;
            meshPulse(0xff4444, 1.8);
        } else {
            display.innerText = "FAILURE: Prime or too large.";
            log("RED: Breach failed. Lock is strong.", '#ff4444');
            addTicker("[RED] BREACH FAILED — LOCK SECURE", "green");
        }

        stressLevel = 0.2;
        systemState = 'NEUTRAL';
        updateBioMetrics();
    }

    // ══════════════════════════════════════
    // PURPLE TEAM: ORIGIN VERIFICATION
    // ══════════════════════════════════════
    async verifyMatch() {
        if (!this.state.foundFactor || !this.state.dnaA) return;

        const found = this.state.foundFactor;
        const display = document.getElementById('purpleOut');
        log("PURPLE TEAM: Verifying origin...", '#d044ff');
        meshPulse(0xd044ff, 1.3);

        const calcA = await this.textToPrime(this.state.dnaA);
        const calcB = await this.textToPrime(this.state.dnaB);

        let matchMsg = "";
        let isMatch = false;

        if (calcA === found) {
            matchMsg = `MATCHED DNA A: "${this.state.dnaA}"`;
            isMatch = true;
        } else if (calcB === found) {
            matchMsg = `MATCHED DNA B: "${this.state.dnaB}"`;
            isMatch = true;
        } else {
            matchMsg = `MISMATCH.\nFound: ${found}\nExp A: ${calcA}\nExp B: ${calcB}`;
        }

        if (isMatch) {
            display.className = "team-output success";
            display.innerText = `ORIGIN VERIFIED.\n${matchMsg}`;
            log("PURPLE: ORIGIN VERIFIED. " + matchMsg, '#4f4');
            addTicker("[PURPLE] ORIGIN VERIFIED", "purple");
            wsSend("PURPLE_VERIFIED:" + matchMsg);

            cognitiveSync = 0.99;
            meshPulse(0x00ff88, 1.0);
            systemState = 'EVOLVING';
            setTimeout(() => { systemState = 'NEUTRAL'; }, 3000);
        } else {
            display.className = "team-output";
            display.innerText = matchMsg;
            log("PURPLE: MISMATCH DETECTED.", '#ff4444');
            addTicker("[PURPLE] CRITICAL MISMATCH", "red");
        }
        updateBioMetrics();
    }

    // ══════════════════════════════════════
    // ENGINE (SHA-256 → Prime, Pollard's Rho)
    // ══════════════════════════════════════
    async textToPrime(text) {
        const msg = new TextEncoder().encode(text);
        const buf = await crypto.subtle.digest('SHA-256', msg);
        const hex = Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
        const SCALE = 1125899906842624n;
        let p = (BigInt('0x' + hex) % SCALE) | 1n;
        while (!this.isPrime(p)) p += 2n;
        return p;
    }

    async pollardsRho(n) {
        if (n % 2n === 0n) return 2n;
        let x = 2n, y = 2n, d = 1n, c = 1n;
        const f = (v) => (v * v + c) % n;
        const gcd = (a, b) => { while (b > 0n) { let t = b; b = a % b; a = t; } return a; };
        const abs = (v) => v < 0n ? -v : v;
        let cycles = 0;
        const BATCH = 50000;
        while (d === 1n) {
            x = f(x); y = f(f(y)); d = gcd(abs(x - y), n);
            cycles++;
            if (cycles % BATCH === 0) {
                document.getElementById('redOut').innerText = `TUNNELING... Cycles: ${cycles.toLocaleString()}`;
                pulseRate = 90 + Math.floor(cycles / BATCH) * 5;
                updateBioMetrics();
                await new Promise(r => setTimeout(r, 0));
            }
        }
        return d === n ? null : d;
    }

    isPrime(n) {
        if (n < 2n) return false;
        if (n % 2n === 0n) return n === 2n;
        for (let i = 3n; i * i <= n; i += 2n) if (n % i === 0n) return false;
        return true;
    }

    updateMetrics() {
        document.getElementById('m_evo').innerText = this.state.evolution.toFixed(2);
        document.getElementById('m_solved').innerText = this.state.solved;
        const auto = Math.min(99, 31 + this.state.solved * 5);
        document.getElementById('autonomy-val').textContent = auto + '%';
        document.getElementById('autonomy-bar').style.width = auto + '%';
    }

    // ENTROPY VISUALIZER (Rule 110 Cellular Automaton)
    async renderEntropy(seed) {
        const msg = new TextEncoder().encode(seed);
        const buf = await crypto.subtle.digest('SHA-256', msg);
        const hex = Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
        let bin = ""; for (let c of hex) bin += parseInt(c, 16).toString(2).padStart(4, '0');
        const w = this.entropyCanvas.width; const h = this.entropyCanvas.height;
        const cols = Math.floor(w / 2);
        let cells = new Array(cols).fill(0).map((_, i) => parseInt(bin[i % bin.length]));
        this.entropyCtx.fillStyle = "#000"; this.entropyCtx.fillRect(0, 0, w, h);
        for (let y = 0; y < h; y++) {
            let next = new Array(cols).fill(0);
            for (let x = 0; x < cols; x++) {
                if (cells[x]) {
                    this.entropyCtx.fillStyle = Math.random() > .9 ? "#fff" : "#4ecdc4";
                    this.entropyCtx.fillRect(x * 2, y, 2, 1);
                }
                let l = cells[(x - 1 + cols) % cols], ce = cells[x], r = cells[(x + 1 + cols) % cols];
                next[x] = [0, 1, 1, 1, 1, 0, 0, 0][7 - parseInt("" + l + ce + r, 2)];
            }
            cells = next;
        }
    }
    renderNoise() { this.renderEntropy(Date.now().toString()); }
}

// ═══════════════════════════════════════════════════════════════════
// THREE.JS VISUALIZER
// ═══════════════════════════════════════════════════════════════════
const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

const geometry = new THREE.IcosahedronGeometry(2, 2);
const material = new THREE.MeshBasicMaterial({ color: 0x00f3ff, wireframe: true, transparent: true, opacity: 0.6 });
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);
document.getElementById('mesh-verts').textContent = geometry.attributes.position.count;

// Store original positions for deformation reset
const origPositions = new Float32Array(geometry.attributes.position.array);

const coreGeo = new THREE.SphereGeometry(0.8, 16, 16);
const coreMat = new THREE.MeshBasicMaterial({ color: 0xff003c, wireframe: true, transparent: true, opacity: 0.4 });
const core = new THREE.Mesh(coreGeo, coreMat);
mesh.add(core);

const ringGeo = new THREE.TorusGeometry(1.618, 0.02, 8, 64);
const ringMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.5 });
const ring = new THREE.Mesh(ringGeo, ringMat);
mesh.add(ring);

camera.position.z = 5;

let time = 0;
let pulseRate = 72;
let stressLevel = 0.1;
let cognitiveSync = 0.86;
let meshDeformation = 0.0;
let systemState = 'NEUTRAL';
let meshPulseScale = 1.0;

function meshPulse(color, intensity) {
    material.color.setHex(color);
    meshPulseScale = intensity;
    setTimeout(() => { meshPulseScale = 1.0; }, 1500);
}

function animate() {
    requestAnimationFrame(animate);
    time += 0.01;

    mesh.rotation.x += 0.003 + Math.sin(time * 1.618) * 0.002;
    mesh.rotation.y += 0.005 + Math.cos(time * 1.618) * 0.002;
    ring.rotation.z += 0.01;

    const scale = meshPulseScale * (1 + Math.sin(time * (pulseRate / 60) * 5) * 0.08);
    mesh.scale.set(scale, scale, scale);

    const coreScale = 0.8 + stressLevel * 0.3 + Math.sin(time * 3) * 0.05;
    core.scale.set(coreScale, coreScale, coreScale);

    // Deformation with reset toward original
    const positions = geometry.attributes.position;
    for (let i = 0; i < positions.count; i++) {
        const ox = origPositions[i * 3];
        const oy = origPositions[i * 3 + 1];
        const oz = origPositions[i * 3 + 2];
        if (meshDeformation > 0.005) {
            const noise = Math.sin(ox * 3 + time * 2) * Math.cos(oy * 3 + time) * meshDeformation;
            positions.setXYZ(i, ox + noise * 0.1, oy + noise * 0.05, oz + noise * 0.1);
        } else {
            positions.setXYZ(i, ox, oy, oz);
        }
    }
    positions.needsUpdate = true;
    meshDeformation *= 0.995; // Decay

    switch (systemState) {
        case 'DEFENSE': material.color.setHex(0xff003c); coreMat.color.setHex(0xff6600); break;
        case 'DREAMING': material.color.setHex(0x00ff88); coreMat.color.setHex(0x8800ff); break;
        case 'EVOLVING': material.color.setHex(0xffd700); coreMat.color.setHex(0x00f3ff); break;
        default:
            if (meshPulseScale <= 1.0) {
                material.color.setHex(pulseRate > 100 ? 0xff003c : 0x00f3ff);
                coreMat.color.setHex(0xff003c);
            }
    }

    renderer.render(scene, camera);
}
animate();

// ═══════════════════════════════════════════════════════════════════
// TERMINAL + BIO
// ═══════════════════════════════════════════════════════════════════
function log(msg, color) {
    const terminal = document.getElementById('console-log');
    const div = document.createElement('div');
    div.style.color = color || 'var(--neon-green)';
    div.innerHTML = "> " + msg;
    terminal.appendChild(div);
    terminal.scrollTop = terminal.scrollHeight;
    while (terminal.children.length > 300) terminal.removeChild(terminal.firstChild);
}

const heartCanvas = document.getElementById('heart-graph');
const hctx = heartCanvas.getContext('2d');
const heartHistory = new Array(200).fill(72);

function drawHeartGraph() {
    hctx.fillStyle = 'rgba(0,0,0,0.3)';
    hctx.fillRect(0, 0, heartCanvas.width, heartCanvas.height);
    hctx.strokeStyle = '#ff003c'; hctx.lineWidth = 1.5; hctx.beginPath();
    for (let i = 0; i < heartHistory.length; i++) {
        const x = (i / heartHistory.length) * heartCanvas.width;
        const y = heartCanvas.height - ((heartHistory[i] - 50) / 80) * heartCanvas.height;
        if (i === 0) hctx.moveTo(x, y); else hctx.lineTo(x, y);
    }
    hctx.stroke();
}

function updateBioMetrics() {
    document.getElementById('hr-display').innerText = pulseRate + " BPM";
    document.getElementById('stress-bar').style.width = (stressLevel * 100) + "%";
    document.getElementById('sync-bar').style.width = (cognitiveSync * 100) + "%";
    document.getElementById('mesh-deform').textContent = meshDeformation.toFixed(4);
    document.getElementById('phys-speed').textContent = (meshDeformation * 10).toFixed(4);
    document.getElementById('phys-speed2').textContent = (meshDeformation * 10).toFixed(4);
    if (stressLevel > 0.7) document.getElementById('stress-bar').style.background = 'var(--neon-red)';
    else if (stressLevel > 0.4) document.getElementById('stress-bar').style.background = '#ffaa00';
    else document.getElementById('stress-bar').style.background = 'var(--neon-blue)';
    heartHistory.push(pulseRate); heartHistory.shift(); drawHeartGraph();
}

// Bio heartbeat loop
setInterval(() => {
    if (systemState === 'NEUTRAL') {
        pulseRate = 70 + Math.floor(Math.random() * 8);
        stressLevel = Math.max(0.05, stressLevel * 0.95 + Math.random() * 0.02);
        cognitiveSync = Math.min(0.99, cognitiveSync * 0.99 + Math.random() * 0.02);
    }
    updateBioMetrics();
}, 1000);

// ═══════════════════════════════════════════════════════════════════
// SUBSYSTEM LIST (Built from real system data)
// ═══════════════════════════════════════════════════════════════════
const SUBSYSTEMS = [
    ["BRAIN","10,000D HDC",true],["CORTEX","NCA@432Hz",true],["KERNEL","PHI-HARMONIC",true],
    ["PRISM","BICAMERAL",true],["SHIELD","AES-256",true],["STONE","AUTOPOIESIS",true],
    ["VISION","LTX-VIDEO",true],["HEADROOM","STANDBY",false],["MIND","SWARM",true],
    ["SOVEREIGN","B/R/P",true],["FVM","16 REGS",true],["PHYSICS","17D HDRB",true],
    ["NEXUS","OS FACTORY",true],["HOLO","KNOWLEDGE",true],["CHRONOS","TEMPORAL",true],
    ["SHELL","INTENT",true],["PLANET","STANDBY",false],["LAZARUS","ARMED",true],
    ["CRYPTO","BIGINTEGER",true],["SOUL","CRYSTAL",true]
];
const subList = document.getElementById('subsystem-list');
SUBSYSTEMS.forEach(([name, desc, on]) => {
    const row = document.createElement('div');
    row.className = 'subsystem-row';
    row.innerHTML = `<span class="name">${name}</span><span class="${on?'status-on':'status-off'}">${desc}</span>`;
    subList.appendChild(row);
});

// ═══════════════════════════════════════════════════════════════════
// TICKER
// ═══════════════════════════════════════════════════════════════════
function addTicker(text, cls) {
    const ticker = document.getElementById('ticker-content');
    const span = document.createElement('span');
    span.className = 'ticker-item ' + (cls || '');
    span.textContent = text;
    ticker.appendChild(span);
}

// ═══════════════════════════════════════════════════════════════════
// WEBSOCKET (Bidirectional to Java Backend)
// ═══════════════════════════════════════════════════════════════════
let socket = null;

function wsSend(msg) {
    if (socket && socket.readyState === WebSocket.OPEN) socket.send(msg);
}

function connectWebSocket() {
    const dot = document.getElementById('conn-dot');
    const status = document.getElementById('conn-status');
    try {
        socket = new WebSocket('ws://localhost:8887');
        socket.onopen = function() {
            dot.className = 'conn-indicator conn-on';
            status.textContent = 'ONLINE'; status.style.color = 'var(--neon-green)';
            log("WEBSOCKET: Connected to FRAYMUS Core.", '#00ff88');
            addTicker("[SYS] JAVA BACKEND CONNECTED", "green");
        };
        socket.onmessage = function(event) {
            const data = event.data;
            const idx = data.indexOf(":");
            if (idx < 1) { log(data, 'var(--neon-green)'); return; }
            const key = data.substring(0, idx);
            const val = data.substring(idx + 1);

            switch (key) {
                case "PULSE": pulseRate = parseInt(val); updateBioMetrics(); break;
                case "STRESS": stressLevel = parseFloat(val); updateBioMetrics(); break;
                case "SYNC": cognitiveSync = parseFloat(val); updateBioMetrics(); break;
                case "DEFORM": meshDeformation = parseFloat(val); break;
                case "SPEED":
                    document.getElementById('phys-speed').textContent = parseFloat(val).toFixed(4);
                    document.getElementById('phys-speed2').textContent = parseFloat(val).toFixed(4);
                    break;
                case "MASS": document.getElementById('phys-mass').textContent = parseFloat(val).toFixed(2); break;
                case "ACC": document.getElementById('fvm-acc').textContent = val; break;
                case "STATE":
                    systemState = val;
                    if (val !== 'NEUTRAL') log("STATE: " + val, '#ffd700');
                    break;
                case "HOLO": document.getElementById('holo-last').textContent = val; break;
                case "CHRONO": {
                    const p = val.split(":");
                    if (p[0]) document.getElementById('chrono-gen').textContent = p[0];
                    if (p[1]) document.getElementById('chrono-score').textContent = parseFloat(p[1]).toFixed(2);
                    break;
                }
                case "NET":
                    document.getElementById('net-status').textContent = val;
                    document.getElementById('net-status').style.color = val === 'LIVE' ? 'var(--neon-green)' : '#555';
                    break;
                case "PEERS": document.getElementById('net-peers').textContent = val; break;
                case "SOUL":
                    document.getElementById('soul-state').textContent = val;
                    document.getElementById('soul-time').textContent = new Date().toLocaleTimeString();
                    break;
                case "EVO": document.getElementById('m_evo').textContent = val; break;
                case "SOLVED": document.getElementById('m_solved').textContent = val; break;
                case "KERNEL": {
                    const kp = val.split(":");
                    // kp[0] = process count, kp[1] = tick count (for future use)
                    break;
                }
                case "LOG": log(val, 'var(--neon-green)'); break;
                default: log(data, 'var(--neon-green)');
            }
        };
        socket.onerror = function() { dot.className='conn-indicator conn-off'; status.textContent='ERROR'; status.style.color='var(--neon-red)'; };
        socket.onclose = function() {
            dot.className='conn-indicator conn-off'; status.textContent='OFFLINE'; status.style.color='var(--neon-red)';
            log("WEBSOCKET: Disconnected. Reconnecting...", '#ff003c');
            setTimeout(connectWebSocket, 5000);
        };
    } catch(e) { log("WebSocket unavailable. Local crypto engine active.", '#ff6600'); }
}
connectWebSocket();

// ═══════════════════════════════════════════════════════════════════
// COMMAND INPUT → Java Backend + Local Crypto
// ═══════════════════════════════════════════════════════════════════
const cmdInput = document.getElementById('cmd-input');
cmdInput.addEventListener('keypress', function(e) {
    if (e.key !== 'Enter') return;
    const text = cmdInput.value.trim();
    if (!text) return;
    log(text, 'var(--neon-blue)');

    // Local command routing
    const tokens = text.split(/\s+/);
    switch(tokens[0].toLowerCase()) {
        case 'auth':
            if (tokens.length >= 3) {
                document.getElementById('blueUser').value = tokens[1];
                document.getElementById('bluePass').value = tokens.slice(2).join(' ');
                sys.generateLock();
            } else { log("Usage: auth <username> <password>", '#ff6600'); }
            break;
        case 'breach': case 'break':
            sys.breakLock();
            break;
        case 'verify':
            sys.verifyMatch();
            break;
        default:
            wsSend(text);
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                log("Queued locally. Java backend offline.", '#888');
            }
    }
    cmdInput.value = '';
});

// ═══════════════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════════════
const sys = new SovereignSystem();
log("FRAYMUS PRIME: Sovereign System initialized.", '#ffd700');
log("Blue/Red/Purple crypto engine LIVE. Type 'auth <user> <pass>' or use buttons.", '#00f3ff');
log("65 files. 20 packages. Zero external dependencies.", '#4ecdc4');

window.addEventListener('resize', () => {
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
});
</script>
</body>
</html>
