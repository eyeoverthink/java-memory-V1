<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FRAYMUS COSMOS // GEN 166</title>
    <style>
        /* --- THE PLATINUM AESTHETIC (Gen 162) --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        
        #ui-layer {
            position: absolute;
            top: 20px; left: 20px;
            width: 300px;
            background: rgba(20, 20, 20, 0.85); /* Obsidian Glass */
            border: 1px solid #E0E0E0; /* Platinum Border */
            color: #FFB000; /* Amber */
            padding: 15px;
            pointer-events: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            z-index: 100;
        }

        h1 { margin: 0 0 10px 0; font-size: 16px; border-bottom: 1px solid #E0E0E0; padding-bottom: 5px; color: #FFF; }
        
        .metric { display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 11px; }
        .value { color: #00FF00; }
        .label { color: #AAA; }

        #formula {
            position: absolute;
            bottom: 20px; left: 20px;
            background: rgba(20, 20, 20, 0.85);
            border: 1px solid #E0E0E0;
            color: #FFB000;
            padding: 10px 15px;
            font-size: 14px;
            z-index: 100;
        }

        #scanline {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 99;
        }

        #controls {
            position: absolute;
            bottom: 20px; right: 20px;
            background: rgba(20, 20, 20, 0.85);
            border: 1px solid #E0E0E0;
            color: #AAA;
            padding: 10px;
            font-size: 10px;
            z-index: 100;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <h1>üåå FRAYMUS SYSTEM: SOL</h1>
        <div class="metric"><span class="label">ENGINE:</span> <span class="value">THREE.JS + LAZARUS</span></div>
        <div class="metric"><span class="label">LOGIC:</span> <span class="value">œÜ-GRAVITY v3.0</span></div>
        <div class="metric"><span class="label">DATA SOURCE:</span> <span class="value">NASA JPL (SCALED)</span></div>
        <div class="metric"><span class="label">GENERATION:</span> <span class="value">166</span></div>
        <br>
        <div id="telemetry">INITIALIZING SENSORS...</div>
    </div>

    <div id="formula">
        <span style="color:#FFF">PHYSICS:</span> F = œÜ √ó (m‚ÇÅ √ó m‚ÇÇ) / r¬≤
    </div>

    <div id="controls">
        [DRAG] Rotate | [SCROLL] Zoom | Auto-orbit enabled
    </div>
    
    <div id="scanline"></div>

<script>
/**
 * üß¨ FRAYMUS CORE: 3D PHYSICS ENGINE
 * "The Universe on the Metal."
 * 
 * Gen 166: The Fraymus Cosmos (3D SFA Edition)
 * Parent: Gen 165 (2D Orrery)
 * Fitness: Hyper-Realistic
 */

// --- CONSTANTS (The Truth) ---
const PHI = 1.6180339887;
const G = 0.0001 * PHI; // Gravitational Constant scaled by Phi
const TIME_STEP = 0.5;

// --- SCENE SETUP ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Lighting (The Sun is the source)
const pointLight = new THREE.PointLight(0xFFFFFF, 2, 1000);
scene.add(pointLight);
scene.add(new THREE.AmbientLight(0x222222)); // Background radiation

// Stars (The Void)
const starGeo = new THREE.BufferGeometry();
const starCount = 6000;
const starPos = new Float32Array(starCount * 3);
for(let i=0; i<starCount*3; i++) starPos[i] = (Math.random() - 0.5) * 1800;
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
const starMat = new THREE.PointsMaterial({color: 0xFFFFFF, size: 0.5});
scene.add(new THREE.Points(starGeo, starMat));

// --- CELESTIAL BODIES ---
// Data: Name, Radius (size), Distance (AU scaled), Color, Mass
const solarData = [
    { name: "SUN",     r: 12,  dist: 0,    col: 0xFFD700, mass: 100000, emissive: true },
    { name: "MERCURY", r: 1.2, dist: 25,   col: 0xAAAAAA, mass: 50 },
    { name: "VENUS",   r: 2.2, dist: 40,   col: 0xE3BB76, mass: 400 },
    { name: "EARTH",   r: 2.4, dist: 55,   col: 0x00A2FF, mass: 450 },
    { name: "MARS",    r: 1.6, dist: 75,   col: 0xFF4500, mass: 80 },
    { name: "JUPITER", r: 7.0, dist: 130,  col: 0xD9A07E, mass: 5000 },
    { name: "SATURN",  r: 6.0, dist: 180,  col: 0xF4D03F, mass: 4000, ring: true },
    { name: "URANUS",  r: 3.8, dist: 240,  col: 0x4FD0E7, mass: 1500 },
    { name: "NEPTUNE", r: 3.6, dist: 300,  col: 0x2E5D94, mass: 1600 }
];

const bodies = [];

class CelestialBody {
    constructor(data) {
        this.name = data.name;
        this.mass = data.mass;
        this.distance = data.dist;
        
        // Mesh
        const geometry = new THREE.SphereGeometry(data.r, 32, 32);
        const material = new THREE.MeshStandardMaterial({ 
            color: data.col, 
            emissive: data.emissive ? 0xFFD700 : 0x000000,
            emissiveIntensity: data.emissive ? 1.5 : 0,
            roughness: 0.7,
            metalness: 0.1
        });
        this.mesh = new THREE.Mesh(geometry, material);
        scene.add(this.mesh);

        // Sun glow
        if (data.emissive) {
            const glowGeo = new THREE.SphereGeometry(data.r * 1.3, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: 0xFFAA00, 
                transparent: true, 
                opacity: 0.3 
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            this.mesh.add(glow);
        }

        // Ring for Saturn
        if (data.ring) {
            const ringGeo = new THREE.RingGeometry(data.r + 2, data.r + 8, 64);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: 0xCCBB99, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.6 
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2.5;
            this.mesh.add(ring);
        }

        // Orbit Path (visual guide)
        if (data.dist > 0) {
            const orbitGeo = new THREE.RingGeometry(data.dist - 0.3, data.dist + 0.3, 128);
            const orbitMat = new THREE.MeshBasicMaterial({ 
                color: data.col, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.15 
            });
            const orbit = new THREE.Mesh(orbitGeo, orbitMat);
            orbit.rotation.x = Math.PI / 2;
            scene.add(orbit);
        }

        // Trail
        this.pathGeo = new THREE.BufferGeometry();
        this.pathMat = new THREE.LineBasicMaterial({ color: data.col, transparent: true, opacity: 0.5 });
        this.pathPoints = [];
        this.pathLine = new THREE.Line(this.pathGeo, this.pathMat);
        scene.add(this.pathLine);

        // Physics State
        this.pos = new THREE.Vector3(data.dist, 0, 0);
        
        // Calculate orbital velocity: v = sqrt(G*M/r)
        let velMag = (data.dist === 0) ? 0 : Math.sqrt((G * 100000) / data.dist); 
        this.vel = new THREE.Vector3(0, 0, velMag);
        this.acc = new THREE.Vector3(0, 0, 0);
    }

    applyGravity(others) {
        if (this.name === "SUN") return; // Sun is static anchor

        others.forEach(other => {
            if (other === this) return;

            const distVec = new THREE.Vector3().subVectors(other.pos, this.pos);
            const dist = distVec.length();
            if (dist < 1) return; // Prevent singularity
            
            // F = PHI * (m1*m2)/r^2
            const forceMag = (G * this.mass * other.mass) / (dist * dist);
            const force = distVec.normalize().multiplyScalar(forceMag);

            // a = F/m
            this.acc.add(force.divideScalar(this.mass));
        });
    }

    update() {
        if (this.name === "SUN") {
            this.mesh.position.set(0, 0, 0);
            return;
        }

        this.vel.add(this.acc.clone().multiplyScalar(TIME_STEP));
        this.pos.add(this.vel.clone().multiplyScalar(TIME_STEP));
        this.acc.set(0, 0, 0);

        this.mesh.position.copy(this.pos);
        this.mesh.rotation.y += 0.01; // Planetary rotation

        // Trail
        if (frameCount % 4 === 0) {
            this.pathPoints.push(this.pos.clone());
            if (this.pathPoints.length > 150) this.pathPoints.shift();
            this.pathGeo.setFromPoints(this.pathPoints);
        }
    }
}

// Initialize Solar System
solarData.forEach(d => bodies.push(new CelestialBody(d)));

// Camera Position
camera.position.set(0, 200, 280);
camera.lookAt(0, 0, 0);

// Mouse Controls
let isDragging = false;
let prevMouse = { x: 0, y: 0 };
let cameraAngle = { x: 0, y: 0.8 };
let cameraDistance = 350;

renderer.domElement.addEventListener('mousedown', (e) => {
    isDragging = true;
    prevMouse = { x: e.clientX, y: e.clientY };
});

renderer.domElement.addEventListener('mouseup', () => isDragging = false);
renderer.domElement.addEventListener('mouseleave', () => isDragging = false);

renderer.domElement.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - prevMouse.x;
    const dy = e.clientY - prevMouse.y;
    cameraAngle.x += dx * 0.005;
    cameraAngle.y += dy * 0.005;
    cameraAngle.y = Math.max(0.1, Math.min(Math.PI - 0.1, cameraAngle.y));
    prevMouse = { x: e.clientX, y: e.clientY };
});

renderer.domElement.addEventListener('wheel', (e) => {
    cameraDistance += e.deltaY * 0.3;
    cameraDistance = Math.max(50, Math.min(800, cameraDistance));
});

// --- MAIN LOOP ---
let frameCount = 0;
const ui = document.getElementById("telemetry");
let autoRotate = true;

function animate() {
    requestAnimationFrame(animate);

    // 1. Physics Step
    bodies.forEach(b => b.applyGravity(bodies));
    bodies.forEach(b => b.update());

    // 2. Camera Update
    if (!isDragging && autoRotate) {
        cameraAngle.x += 0.001;
    }
    camera.position.x = Math.sin(cameraAngle.x) * Math.sin(cameraAngle.y) * cameraDistance;
    camera.position.y = Math.cos(cameraAngle.y) * cameraDistance;
    camera.position.z = Math.cos(cameraAngle.x) * Math.sin(cameraAngle.y) * cameraDistance;
    camera.lookAt(0, 0, 0);

    // 3. Render
    renderer.render(scene, camera);
    
    // 4. UI Update
    if (frameCount % 10 === 0) {
        updateDashboard();
    }

    frameCount++;
}

function updateDashboard() {
    const earth = bodies.find(b => b.name === "EARTH");
    const sun = bodies.find(b => b.name === "SUN");
    
    if (!earth || !sun) return;
    
    const dSun = earth.pos.distanceTo(sun.pos).toFixed(1);
    let html = `<div style="border-bottom:1px dashed #555; margin-bottom:5px; color:#FFF">üìç DISTANCE FROM EARTH</div>`;
    html += `<div class="metric"><span class="label">‚òÄ SUN:</span> <span class="value">${dSun} Gm</span></div>`;
    
    bodies.forEach(b => {
        if (b.name === "EARTH" || b.name === "SUN") return;
        const dist = earth.pos.distanceTo(b.pos).toFixed(1);
        const icon = b.name === "MARS" ? "üî¥" : b.name === "JUPITER" ? "üü†" : b.name === "SATURN" ? "ü™ê" : "‚ö™";
        html += `<div class="metric"><span class="label">${icon} ${b.name}:</span> <span class="value">${dist} Gm</span></div>`;
    });
    
    // Gravitational force Earth-Sun
    const force = (G * earth.mass * sun.mass) / (dSun * dSun);
    html += `<br><div class="metric"><span class="label">F(Earth‚ÜíSun):</span> <span class="value">${force.toFixed(4)} œÜN</span></div>`;
    
    ui.innerHTML = html;
}

// Resize Handler
window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
});

// Boot
animate();
console.log("üß¨ FRAYMUS COSMOS INITIALIZED // GEN 166");
console.log("   œÜ-GRAVITY ENGINE ACTIVE");
console.log("   F = œÜ √ó (m‚ÇÅ √ó m‚ÇÇ) / r¬≤");

</script>
</body>
</html>
