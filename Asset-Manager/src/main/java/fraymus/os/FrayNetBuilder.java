package fraymus.os;

import java.io.*;
import java.nio.file.*;

/**
 * ğŸ“¡ FRAY-NET BUILDER - Gen 146
 * "Raw socket injection on bare metal."
 * 
 * Bare metal network stack - no TCP overhead.
 * Direct UDP/IP/Ethernet for low-latency gaming.
 * 
 * Features:
 *   - Ethernet frame construction
 *   - IP header with checksum
 *   - UDP for game data
 *   - ARP for MAC resolution
 *   - E1000 NIC driver (virtual)
 * 
 * "The machines speak to each other."
 */
public class FrayNetBuilder {

    private static final String OUTPUT_DIR = "fraynix_src";

    public static void main(String[] args) {
        System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘  ğŸ“¡ FRAY-NET BUILDER - Gen 146                                â•‘");
        System.out.println("â•‘  Bare Metal Network Stack                                     â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        System.out.println();
        
        try {
            Files.createDirectories(Paths.get(OUTPUT_DIR));
            
            System.out.println("âš¡ Generating network stack...");
            
            buildNetworkStack();
            buildE1000Driver();
            
            System.out.println();
            System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            System.out.println("â•‘  âœ… FRAY-NET INSTALLED                                        â•‘");
            System.out.println("â•‘                                                               â•‘");
            System.out.println("â•‘  Output: fraynix_src/net.c                                   â•‘");
            System.out.println("â•‘          fraynix_src/e1000.c                                 â•‘");
            System.out.println("â•‘                                                               â•‘");
            System.out.println("â•‘  Protocols: Ethernet, IP, UDP, ARP                           â•‘");
            System.out.println("â•‘  Driver:    Intel E1000 (Virtual)                            â•‘");
            System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            
        } catch (IOException e) {
            System.err.println("âŒ BUILD FAILED: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void buildNetworkStack() throws IOException {
        System.out.println("   [1/2] Generating net.c...");
        
        String net = """
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * FRAY-NET: BARE METAL NETWORK STACK
 * Generated by Fraymus - Gen 146
 * 
 * Protocols:
 *   - Ethernet II (Layer 2)
 *   - ARP (Address Resolution)
 *   - IPv4 (Layer 3)
 *   - UDP (Layer 4)
 * 
 * "Raw packets. No kernel overhead. Pure speed."
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#ifndef FRAY_NET_C
#define FRAY_NET_C

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * NETWORK CONFIGURATION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

static unsigned char my_mac[6] = { 0x52, 0x54, 0x00, 0x12, 0x34, 0x56 };
static unsigned char my_ip[4] = { 192, 168, 1, 100 };
static unsigned char gateway_ip[4] = { 192, 168, 1, 1 };
static unsigned char broadcast_mac[6] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

/* Game server */
static unsigned char server_ip[4] = { 192, 168, 1, 1 };
static unsigned short game_port = 7777;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PACKET STRUCTURES
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Ethernet Header (14 bytes) */
typedef struct __attribute__((packed)) {
    unsigned char dest_mac[6];
    unsigned char src_mac[6];
    unsigned short ethertype;  /* 0x0800 = IP, 0x0806 = ARP */
} EthernetHeader;

/* IPv4 Header (20 bytes minimum) */
typedef struct __attribute__((packed)) {
    unsigned char version_ihl;      /* Version (4) + IHL (5) = 0x45 */
    unsigned char tos;              /* Type of Service */
    unsigned short total_length;    /* Total packet length */
    unsigned short id;              /* Identification */
    unsigned short flags_fragment;  /* Flags + Fragment offset */
    unsigned char ttl;              /* Time to Live */
    unsigned char protocol;         /* 17 = UDP, 6 = TCP */
    unsigned short checksum;        /* Header checksum */
    unsigned char src_ip[4];
    unsigned char dest_ip[4];
} IPHeader;

/* UDP Header (8 bytes) */
typedef struct __attribute__((packed)) {
    unsigned short src_port;
    unsigned short dest_port;
    unsigned short length;
    unsigned short checksum;
} UDPHeader;

/* ARP Packet */
typedef struct __attribute__((packed)) {
    unsigned short hw_type;         /* 1 = Ethernet */
    unsigned short proto_type;      /* 0x0800 = IP */
    unsigned char hw_size;          /* 6 for MAC */
    unsigned char proto_size;       /* 4 for IP */
    unsigned short opcode;          /* 1 = Request, 2 = Reply */
    unsigned char sender_mac[6];
    unsigned char sender_ip[4];
    unsigned char target_mac[6];
    unsigned char target_ip[4];
} ARPPacket;

/* Game Packet Payload */
typedef struct __attribute__((packed)) {
    char magic[4];          /* "FRAY" */
    unsigned char type;     /* 0=Position, 1=Chat, 2=Event */
    unsigned short player_id;
    int pos_x;
    int pos_y;
    int pos_z;
    int dir_angle;
    unsigned char health;
    unsigned char ammo;
} GamePacket;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PACKET BUFFERS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#define MAX_PACKET_SIZE 1518
#define RX_BUFFER_SIZE  16
#define TX_BUFFER_SIZE  16

static unsigned char tx_buffer[TX_BUFFER_SIZE][MAX_PACKET_SIZE];
static unsigned char rx_buffer[RX_BUFFER_SIZE][MAX_PACKET_SIZE];
static int tx_head = 0, tx_tail = 0;
static int rx_head = 0, rx_tail = 0;

/* Statistics */
static unsigned int packets_sent = 0;
static unsigned int packets_received = 0;
static unsigned int packets_dropped = 0;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * CHECKSUM CALCULATION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

static unsigned short ip_checksum(void* data, int len) {
    unsigned int sum = 0;
    unsigned short* ptr = (unsigned short*)data;
    
    while (len > 1) {
        sum += *ptr++;
        len -= 2;
    }
    
    if (len == 1) {
        sum += *(unsigned char*)ptr;
    }
    
    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    
    return ~sum;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * BYTE ORDER CONVERSION (Network = Big Endian)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

static inline unsigned short htons(unsigned short h) {
    return ((h & 0xFF) << 8) | ((h >> 8) & 0xFF);
}

static inline unsigned short ntohs(unsigned short n) {
    return htons(n);
}

static inline unsigned int htonl(unsigned int h) {
    return ((h & 0xFF) << 24) | ((h & 0xFF00) << 8) |
           ((h >> 8) & 0xFF00) | ((h >> 24) & 0xFF);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PACKET CONSTRUCTION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

int net_build_udp_packet(unsigned char* buffer, 
                         unsigned char* dest_mac,
                         unsigned char* dest_ip,
                         unsigned short dest_port,
                         unsigned char* payload,
                         int payload_len) {
    
    int offset = 0;
    
    /* Ethernet Header */
    EthernetHeader* eth = (EthernetHeader*)buffer;
    for (int i = 0; i < 6; i++) {
        eth->dest_mac[i] = dest_mac[i];
        eth->src_mac[i] = my_mac[i];
    }
    eth->ethertype = htons(0x0800);  /* IP */
    offset += sizeof(EthernetHeader);
    
    /* IP Header */
    IPHeader* ip = (IPHeader*)(buffer + offset);
    ip->version_ihl = 0x45;  /* IPv4, 5 words */
    ip->tos = 0;
    ip->total_length = htons(sizeof(IPHeader) + sizeof(UDPHeader) + payload_len);
    ip->id = htons(packets_sent);
    ip->flags_fragment = 0;
    ip->ttl = 64;
    ip->protocol = 17;  /* UDP */
    ip->checksum = 0;
    for (int i = 0; i < 4; i++) {
        ip->src_ip[i] = my_ip[i];
        ip->dest_ip[i] = dest_ip[i];
    }
    ip->checksum = ip_checksum(ip, sizeof(IPHeader));
    offset += sizeof(IPHeader);
    
    /* UDP Header */
    UDPHeader* udp = (UDPHeader*)(buffer + offset);
    udp->src_port = htons(game_port);
    udp->dest_port = htons(dest_port);
    udp->length = htons(sizeof(UDPHeader) + payload_len);
    udp->checksum = 0;  /* Optional for UDP */
    offset += sizeof(UDPHeader);
    
    /* Payload */
    for (int i = 0; i < payload_len; i++) {
        buffer[offset + i] = payload[i];
    }
    offset += payload_len;
    
    return offset;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * GAME NETWORKING
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

void net_broadcast_position(int x, int y, int z, int angle) {
    GamePacket game;
    game.magic[0] = 'F';
    game.magic[1] = 'R';
    game.magic[2] = 'A';
    game.magic[3] = 'Y';
    game.type = 0;  /* Position update */
    game.player_id = 1;
    game.pos_x = x;
    game.pos_y = y;
    game.pos_z = z;
    game.dir_angle = angle;
    game.health = 100;
    game.ammo = 50;
    
    unsigned char packet[MAX_PACKET_SIZE];
    int len = net_build_udp_packet(packet, broadcast_mac, server_ip, 
                                   game_port, (unsigned char*)&game, sizeof(GamePacket));
    
    e1000_transmit(packet, len);
    packets_sent++;
}

void net_send_chat(const char* message) {
    unsigned char payload[256];
    payload[0] = 'F'; payload[1] = 'R'; payload[2] = 'A'; payload[3] = 'Y';
    payload[4] = 1;  /* Chat type */
    
    int i = 0;
    while (message[i] && i < 250) {
        payload[5 + i] = message[i];
        i++;
    }
    payload[5 + i] = 0;
    
    unsigned char packet[MAX_PACKET_SIZE];
    int len = net_build_udp_packet(packet, broadcast_mac, server_ip,
                                   game_port, payload, 6 + i);
    
    e1000_transmit(packet, len);
    packets_sent++;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PACKET RECEPTION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

void net_process_packet(unsigned char* packet, int len) {
    EthernetHeader* eth = (EthernetHeader*)packet;
    
    /* Check if packet is for us or broadcast */
    int for_us = 1;
    for (int i = 0; i < 6; i++) {
        if (eth->dest_mac[i] != my_mac[i] && eth->dest_mac[i] != 0xFF) {
            for_us = 0;
            break;
        }
    }
    if (!for_us) return;
    
    unsigned short ethertype = ntohs(eth->ethertype);
    
    if (ethertype == 0x0800) {
        /* IP Packet */
        IPHeader* ip = (IPHeader*)(packet + sizeof(EthernetHeader));
        
        if (ip->protocol == 17) {
            /* UDP */
            UDPHeader* udp = (UDPHeader*)(packet + sizeof(EthernetHeader) + sizeof(IPHeader));
            unsigned char* payload = packet + sizeof(EthernetHeader) + sizeof(IPHeader) + sizeof(UDPHeader);
            
            /* Check for game packet */
            if (payload[0] == 'F' && payload[1] == 'R' && 
                payload[2] == 'A' && payload[3] == 'Y') {
                GamePacket* game = (GamePacket*)payload;
                
                /* Handle game packet based on type */
                if (game->type == 0) {
                    /* Position update from another player */
                    kprint("[NET] Player ");
                    kprint_int(game->player_id);
                    kprint(" at (");
                    kprint_int(game->pos_x);
                    kprint(",");
                    kprint_int(game->pos_y);
                    kprint(")\\n");
                }
            }
        }
    } else if (ethertype == 0x0806) {
        /* ARP - respond to requests for our IP */
        /* (Implementation omitted for brevity) */
    }
    
    packets_received++;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * INITIALIZATION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

void net_init(void) {
    kprint_color("\\n  FRAY-NET INITIALIZING...\\n", 0x0A);
    
    e1000_init();
    
    kprint("  MAC: ");
    for (int i = 0; i < 6; i++) {
        if (i > 0) kprint(":");
        kprint_hex(my_mac[i]);
    }
    kprint("\\n");
    
    kprint("  IP:  ");
    for (int i = 0; i < 4; i++) {
        if (i > 0) kprint(".");
        kprint_int(my_ip[i]);
    }
    kprint("\\n");
    
    kprint_color("  NETWORK ONLINE\\n\\n", 0x0A);
}

void net_status(void) {
    kprint_color("\\n  NETWORK STATUS\\n", 0x0B);
    kprint("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
    kprint("  Packets sent:     ");
    kprint_int(packets_sent);
    kprint("\\n");
    kprint("  Packets received: ");
    kprint_int(packets_received);
    kprint("\\n");
    kprint("  Packets dropped:  ");
    kprint_int(packets_dropped);
    kprint("\\n\\n");
}

#endif /* FRAY_NET_C */
""";
        
        writeFile(OUTPUT_DIR + "/net.c", net);
    }

    private static void buildE1000Driver() throws IOException {
        System.out.println("   [2/2] Generating e1000.c...");
        
        String e1000 = """
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * E1000 NETWORK DRIVER
 * Generated by Fraymus - Gen 146
 * 
 * Virtual Intel E1000 NIC driver for QEMU/VirtualBox
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#ifndef FRAY_E1000_C
#define FRAY_E1000_C

/* E1000 Register Offsets */
#define E1000_CTRL      0x0000
#define E1000_STATUS    0x0008
#define E1000_EERD      0x0014
#define E1000_ICR       0x00C0
#define E1000_IMS       0x00D0
#define E1000_IMC       0x00D8
#define E1000_RCTL      0x0100
#define E1000_TCTL      0x0400
#define E1000_RDBAL     0x2800
#define E1000_RDBAH     0x2804
#define E1000_RDLEN     0x2808
#define E1000_RDH       0x2810
#define E1000_RDT       0x2818
#define E1000_TDBAL     0x3800
#define E1000_TDBAH     0x3804
#define E1000_TDLEN     0x3808
#define E1000_TDH       0x3810
#define E1000_TDT       0x3818

/* Transmit Descriptor */
typedef struct __attribute__((packed)) {
    unsigned long long addr;
    unsigned short length;
    unsigned char cso;
    unsigned char cmd;
    unsigned char sta;
    unsigned char css;
    unsigned short special;
} E1000TxDesc;

/* Receive Descriptor */
typedef struct __attribute__((packed)) {
    unsigned long long addr;
    unsigned short length;
    unsigned short checksum;
    unsigned char status;
    unsigned char errors;
    unsigned short special;
} E1000RxDesc;

#define TX_DESC_COUNT 32
#define RX_DESC_COUNT 32

static E1000TxDesc tx_descs[TX_DESC_COUNT] __attribute__((aligned(16)));
static E1000RxDesc rx_descs[RX_DESC_COUNT] __attribute__((aligned(16)));
static unsigned char tx_buffers[TX_DESC_COUNT][2048] __attribute__((aligned(16)));
static unsigned char rx_buffers[RX_DESC_COUNT][2048] __attribute__((aligned(16)));

static unsigned int e1000_base = 0;  /* MMIO base address */
static int tx_cur = 0;
static int rx_cur = 0;

/* Read/Write E1000 registers */
static inline void e1000_write(unsigned int reg, unsigned int val) {
    *(volatile unsigned int*)(e1000_base + reg) = val;
}

static inline unsigned int e1000_read(unsigned int reg) {
    return *(volatile unsigned int*)(e1000_base + reg);
}

void e1000_init(void) {
    /* In a real driver, we would:
     * 1. Scan PCI for E1000 device (vendor 0x8086, device 0x100E)
     * 2. Map MMIO registers
     * 3. Reset the device
     * 4. Set up TX/RX descriptor rings
     * 5. Enable interrupts
     * 
     * For simulation, we assume e1000_base is pre-configured
     */
    
    /* Initialize TX descriptors */
    for (int i = 0; i < TX_DESC_COUNT; i++) {
        tx_descs[i].addr = (unsigned long long)(unsigned int)tx_buffers[i];
        tx_descs[i].cmd = 0;
        tx_descs[i].sta = 1;  /* DD (Descriptor Done) */
    }
    
    /* Initialize RX descriptors */
    for (int i = 0; i < RX_DESC_COUNT; i++) {
        rx_descs[i].addr = (unsigned long long)(unsigned int)rx_buffers[i];
        rx_descs[i].status = 0;
    }
    
    kprint("  E1000 NIC initialized\\n");
}

void e1000_transmit(unsigned char* data, int len) {
    if (len > 1518) len = 1518;
    
    /* Wait for descriptor to be available */
    while (!(tx_descs[tx_cur].sta & 1)) {
        /* Busy wait - in real driver, use interrupts */
    }
    
    /* Copy data to buffer */
    for (int i = 0; i < len; i++) {
        tx_buffers[tx_cur][i] = data[i];
    }
    
    /* Set up descriptor */
    tx_descs[tx_cur].length = len;
    tx_descs[tx_cur].cmd = 0x0B;  /* EOP | IFCS | RS */
    tx_descs[tx_cur].sta = 0;
    
    /* Notify hardware */
    int old_cur = tx_cur;
    tx_cur = (tx_cur + 1) % TX_DESC_COUNT;
    
    /* In real driver: e1000_write(E1000_TDT, tx_cur); */
    
    /* Simulate immediate completion */
    tx_descs[old_cur].sta = 1;
    
    kprint_color(" [NET] TX: ", 0x0A);
    kprint_int(len);
    kprint(" bytes\\n");
}

int e1000_receive(unsigned char* buffer, int max_len) {
    /* Check if packet available */
    if (!(rx_descs[rx_cur].status & 1)) {
        return 0;  /* No packet */
    }
    
    int len = rx_descs[rx_cur].length;
    if (len > max_len) len = max_len;
    
    /* Copy data */
    for (int i = 0; i < len; i++) {
        buffer[i] = rx_buffers[rx_cur][i];
    }
    
    /* Reset descriptor */
    rx_descs[rx_cur].status = 0;
    rx_cur = (rx_cur + 1) % RX_DESC_COUNT;
    
    /* In real driver: e1000_write(E1000_RDT, rx_cur); */
    
    return len;
}

#endif /* FRAY_E1000_C */
""";
        
        writeFile(OUTPUT_DIR + "/e1000.c", e1000);
    }

    private static void writeFile(String path, String content) throws IOException {
        Path filePath = Paths.get(path);
        Files.createDirectories(filePath.getParent());
        Files.writeString(filePath, content);
        System.out.println("      â†’ " + path);
    }
}
