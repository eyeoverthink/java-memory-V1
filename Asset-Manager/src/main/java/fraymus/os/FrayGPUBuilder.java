package fraymus.os;

import java.io.*;
import java.nio.file.*;

/**
 * ğŸ® FRAY GPU BUILDER - Gen 145
 * "If you can do Math, you don't need Nvidia."
 * 
 * Software 3D Rasterizer - The Reality Engine
 * 
 * Features:
 *   - 3D vector/matrix math (no FPU required)
 *   - Fixed-point arithmetic
 *   - Perspective projection
 *   - Rotation matrices (X, Y, Z axes)
 *   - Wireframe rendering
 *   - Flat shading
 *   - Z-buffer (depth sorting)
 * 
 * The CPU becomes the GPU.
 * Pure mathematics renders reality.
 * 
 * "The Machine hallucinates 3D space."
 */
public class FrayGPUBuilder {

    private static final String OUTPUT_DIR = "fraynix_src";

    public static void main(String[] args) {
        System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘  ğŸ® FRAY GPU BUILDER - Gen 145                                â•‘");
        System.out.println("â•‘  Software 3D Rasterizer (The Reality Engine)                 â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        System.out.println();
        
        try {
            Files.createDirectories(Paths.get(OUTPUT_DIR));
            
            System.out.println("âš¡ Generating 3D engine components...");
            
            buildMathLibrary();
            build3DEngine();
            buildMeshData();
            
            System.out.println();
            System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            System.out.println("â•‘  âœ… VIRTUAL GPU INSTALLED                                     â•‘");
            System.out.println("â•‘                                                               â•‘");
            System.out.println("â•‘  Output: fraynix_src/math3d.c                                â•‘");
            System.out.println("â•‘          fraynix_src/gpu.c                                   â•‘");
            System.out.println("â•‘          fraynix_src/meshes.c                                â•‘");
            System.out.println("â•‘                                                               â•‘");
            System.out.println("â•‘  Features: Rotation, Projection, Wireframe, Z-Buffer         â•‘");
            System.out.println("â•‘  Demo: Spinning 3D Cube                                      â•‘");
            System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            
        } catch (IOException e) {
            System.err.println("âŒ BUILD FAILED: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void buildMathLibrary() throws IOException {
        System.out.println("   [1/3] Generating math3d.c...");
        
        String math = """
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * FRAY-MATH: 3D MATHEMATICS LIBRARY
 * Generated by Fraymus - Gen 145
 * 
 * Fixed-point arithmetic for FPU-less systems
 * All values scaled by 256 (8.8 fixed point)
 * 
 * "Pure math needs no hardware."
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#ifndef FRAY_MATH3D_C
#define FRAY_MATH3D_C

/* Fixed-point scale factor */
#define FP_SHIFT 8
#define FP_ONE   (1 << FP_SHIFT)  /* 256 */
#define FP_HALF  (FP_ONE >> 1)     /* 128 */

/* Convert int to fixed-point */
#define INT_TO_FP(x) ((x) << FP_SHIFT)
#define FP_TO_INT(x) ((x) >> FP_SHIFT)

/* Fixed-point multiply */
#define FP_MUL(a, b) (((a) * (b)) >> FP_SHIFT)

/* Fixed-point divide */
#define FP_DIV(a, b) (((a) << FP_SHIFT) / (b))

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * TRIGONOMETRY LOOKUP TABLES
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Sin table: 256 entries for 0-360 degrees, scaled by 256 */
static const int sin_table[256] = {
    0, 6, 12, 18, 25, 31, 37, 43, 49, 56, 62, 68, 74, 80, 86, 92,
    97, 103, 109, 115, 120, 126, 131, 136, 142, 147, 152, 157, 162, 167, 171, 176,
    180, 185, 189, 193, 197, 201, 205, 209, 212, 216, 219, 222, 225, 228, 231, 233,
    236, 238, 240, 242, 244, 246, 247, 249, 250, 251, 252, 253, 254, 254, 255, 255,
    256, 255, 255, 254, 254, 253, 252, 251, 250, 249, 247, 246, 244, 242, 240, 238,
    236, 233, 231, 228, 225, 222, 219, 216, 212, 209, 205, 201, 197, 193, 189, 185,
    180, 176, 171, 167, 162, 157, 152, 147, 142, 136, 131, 126, 120, 115, 109, 103,
    97, 92, 86, 80, 74, 68, 62, 56, 49, 43, 37, 31, 25, 18, 12, 6,
    0, -6, -12, -18, -25, -31, -37, -43, -49, -56, -62, -68, -74, -80, -86, -92,
    -97, -103, -109, -115, -120, -126, -131, -136, -142, -147, -152, -157, -162, -167, -171, -176,
    -180, -185, -189, -193, -197, -201, -205, -209, -212, -216, -219, -222, -225, -228, -231, -233,
    -236, -238, -240, -242, -244, -246, -247, -249, -250, -251, -252, -253, -254, -254, -255, -255,
    -256, -255, -255, -254, -254, -253, -252, -251, -250, -249, -247, -246, -244, -242, -240, -238,
    -236, -233, -231, -228, -225, -222, -219, -216, -212, -209, -205, -201, -197, -193, -189, -185,
    -180, -176, -171, -167, -162, -157, -152, -147, -142, -136, -131, -126, -120, -115, -109, -103,
    -97, -92, -86, -80, -74, -68, -62, -56, -49, -43, -37, -31, -25, -18, -12, -6
};

static inline int fp_sin(int angle) {
    return sin_table[angle & 0xFF];
}

static inline int fp_cos(int angle) {
    return sin_table[(angle + 64) & 0xFF];
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * VECTOR TYPES
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

typedef struct {
    int x, y, z;  /* Fixed-point */
} Vec3;

typedef struct {
    int x, y;     /* Screen coordinates */
} Point2D;

typedef struct {
    int m[3][3];  /* 3x3 rotation matrix, fixed-point */
} Mat3;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * VECTOR OPERATIONS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

static inline Vec3 vec3_add(Vec3 a, Vec3 b) {
    Vec3 r = { a.x + b.x, a.y + b.y, a.z + b.z };
    return r;
}

static inline Vec3 vec3_sub(Vec3 a, Vec3 b) {
    Vec3 r = { a.x - b.x, a.y - b.y, a.z - b.z };
    return r;
}

static inline Vec3 vec3_scale(Vec3 v, int s) {
    Vec3 r = { FP_MUL(v.x, s), FP_MUL(v.y, s), FP_MUL(v.z, s) };
    return r;
}

static inline int vec3_dot(Vec3 a, Vec3 b) {
    return FP_MUL(a.x, b.x) + FP_MUL(a.y, b.y) + FP_MUL(a.z, b.z);
}

static inline Vec3 vec3_cross(Vec3 a, Vec3 b) {
    Vec3 r;
    r.x = FP_MUL(a.y, b.z) - FP_MUL(a.z, b.y);
    r.y = FP_MUL(a.z, b.x) - FP_MUL(a.x, b.z);
    r.z = FP_MUL(a.x, b.y) - FP_MUL(a.y, b.x);
    return r;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * MATRIX OPERATIONS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

static inline Vec3 mat3_mul_vec(Mat3* m, Vec3 v) {
    Vec3 r;
    r.x = FP_MUL(m->m[0][0], v.x) + FP_MUL(m->m[0][1], v.y) + FP_MUL(m->m[0][2], v.z);
    r.y = FP_MUL(m->m[1][0], v.x) + FP_MUL(m->m[1][1], v.y) + FP_MUL(m->m[1][2], v.z);
    r.z = FP_MUL(m->m[2][0], v.x) + FP_MUL(m->m[2][1], v.y) + FP_MUL(m->m[2][2], v.z);
    return r;
}

/* Rotation around X axis */
void mat3_rot_x(Mat3* m, int angle) {
    int c = fp_cos(angle);
    int s = fp_sin(angle);
    m->m[0][0] = FP_ONE; m->m[0][1] = 0;  m->m[0][2] = 0;
    m->m[1][0] = 0;      m->m[1][1] = c;  m->m[1][2] = -s;
    m->m[2][0] = 0;      m->m[2][1] = s;  m->m[2][2] = c;
}

/* Rotation around Y axis */
void mat3_rot_y(Mat3* m, int angle) {
    int c = fp_cos(angle);
    int s = fp_sin(angle);
    m->m[0][0] = c;  m->m[0][1] = 0;      m->m[0][2] = s;
    m->m[1][0] = 0;  m->m[1][1] = FP_ONE; m->m[1][2] = 0;
    m->m[2][0] = -s; m->m[2][1] = 0;      m->m[2][2] = c;
}

/* Rotation around Z axis */
void mat3_rot_z(Mat3* m, int angle) {
    int c = fp_cos(angle);
    int s = fp_sin(angle);
    m->m[0][0] = c;  m->m[0][1] = -s; m->m[0][2] = 0;
    m->m[1][0] = s;  m->m[1][1] = c;  m->m[1][2] = 0;
    m->m[2][0] = 0;  m->m[2][1] = 0;  m->m[2][2] = FP_ONE;
}

#endif /* FRAY_MATH3D_C */
""";
        
        writeFile(OUTPUT_DIR + "/math3d.c", math);
    }

    private static void build3DEngine() throws IOException {
        System.out.println("   [2/3] Generating gpu.c...");
        
        String gpu = """
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * FRAY-GPU: SOFTWARE 3D RASTERIZER
 * Generated by Fraymus - Gen 145
 * 
 * Complete 3D rendering pipeline in pure C
 * 
 * Pipeline:
 *   1. Model Space â†’ World Space (transform)
 *   2. World Space â†’ Camera Space (view)
 *   3. Camera Space â†’ Clip Space (projection)
 *   4. Clip Space â†’ Screen Space (viewport)
 *   5. Rasterization (draw pixels)
 * 
 * "The CPU becomes the GPU."
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#ifndef FRAY_GPU_C
#define FRAY_GPU_C

#include "math3d.c"

/* Screen dimensions (Mode 13h) */
#define GPU_WIDTH  320
#define GPU_HEIGHT 200

/* Camera settings */
#define GPU_FOV         128   /* Field of view scale */
#define GPU_NEAR        FP_ONE
#define GPU_FAR         INT_TO_FP(100)
#define GPU_DISTANCE    INT_TO_FP(5)  /* Camera distance from origin */

/* Z-buffer */
static int zbuffer[GPU_WIDTH * GPU_HEIGHT];

/* Frame counter */
static unsigned int gpu_frame = 0;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PROJECTION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

Point2D gpu_project(Vec3 p) {
    Point2D screen;
    
    /* Translate away from camera */
    int z = p.z + GPU_DISTANCE;
    
    /* Prevent divide by zero */
    if (z < FP_ONE) z = FP_ONE;
    
    /* Perspective divide */
    screen.x = FP_DIV(FP_MUL(p.x, INT_TO_FP(GPU_FOV)), z) + (GPU_WIDTH / 2);
    screen.y = FP_DIV(FP_MUL(p.y, INT_TO_FP(GPU_FOV)), z) + (GPU_HEIGHT / 2);
    
    return screen;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Z-BUFFER
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

void gpu_clear_zbuffer(void) {
    for (int i = 0; i < GPU_WIDTH * GPU_HEIGHT; i++) {
        zbuffer[i] = 0x7FFFFFFF;  /* Max int */
    }
}

int gpu_test_z(int x, int y, int z) {
    if (x < 0 || x >= GPU_WIDTH || y < 0 || y >= GPU_HEIGHT) return 0;
    int idx = y * GPU_WIDTH + x;
    if (z < zbuffer[idx]) {
        zbuffer[idx] = z;
        return 1;
    }
    return 0;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * DRAWING PRIMITIVES
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

void gpu_draw_line_3d(Vec3 a, Vec3 b, unsigned char color) {
    Point2D p1 = gpu_project(a);
    Point2D p2 = gpu_project(b);
    
    /* Bresenham's line */
    int dx = p2.x - p1.x;
    int dy = p2.y - p1.y;
    int sx = dx > 0 ? 1 : -1;
    int sy = dy > 0 ? 1 : -1;
    dx = dx < 0 ? -dx : dx;
    dy = dy < 0 ? -dy : dy;
    
    int err = (dx > dy ? dx : -dy) / 2;
    int x = p1.x, y = p1.y;
    
    while (1) {
        vga_put_pixel(x, y, color);
        if (x == p2.x && y == p2.y) break;
        int e2 = err;
        if (e2 > -dx) { err -= dy; x += sx; }
        if (e2 < dy)  { err += dx; y += sy; }
    }
}

void gpu_draw_triangle_wire(Vec3 a, Vec3 b, Vec3 c, unsigned char color) {
    gpu_draw_line_3d(a, b, color);
    gpu_draw_line_3d(b, c, color);
    gpu_draw_line_3d(c, a, color);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * MESH RENDERING
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

typedef struct {
    Vec3* vertices;
    int vertex_count;
    int* indices;      /* Triangles: v0, v1, v2, v0, v1, v2, ... */
    int index_count;
    unsigned char color;
} Mesh;

void gpu_draw_mesh(Mesh* mesh, Mat3* rotation, Vec3 position) {
    /* Transform and project all vertices */
    Point2D* projected = (Point2D*)kmalloc(mesh->vertex_count * sizeof(Point2D));
    Vec3* transformed = (Vec3*)kmalloc(mesh->vertex_count * sizeof(Vec3));
    
    for (int i = 0; i < mesh->vertex_count; i++) {
        /* Rotate */
        transformed[i] = mat3_mul_vec(rotation, mesh->vertices[i]);
        /* Translate */
        transformed[i] = vec3_add(transformed[i], position);
        /* Project */
        projected[i] = gpu_project(transformed[i]);
    }
    
    /* Draw wireframe triangles */
    for (int i = 0; i < mesh->index_count; i += 3) {
        int i0 = mesh->indices[i];
        int i1 = mesh->indices[i + 1];
        int i2 = mesh->indices[i + 2];
        
        gpu_draw_triangle_wire(
            transformed[i0], 
            transformed[i1], 
            transformed[i2], 
            mesh->color
        );
    }
    
    kfree(projected);
    kfree(transformed);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * CUBE MESH
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

static Vec3 cube_vertices[8] = {
    { -FP_ONE, -FP_ONE, -FP_ONE },
    {  FP_ONE, -FP_ONE, -FP_ONE },
    {  FP_ONE,  FP_ONE, -FP_ONE },
    { -FP_ONE,  FP_ONE, -FP_ONE },
    { -FP_ONE, -FP_ONE,  FP_ONE },
    {  FP_ONE, -FP_ONE,  FP_ONE },
    {  FP_ONE,  FP_ONE,  FP_ONE },
    { -FP_ONE,  FP_ONE,  FP_ONE }
};

static int cube_indices[36] = {
    /* Front */  0, 1, 2, 0, 2, 3,
    /* Back */   4, 6, 5, 4, 7, 6,
    /* Left */   0, 3, 7, 0, 7, 4,
    /* Right */  1, 5, 6, 1, 6, 2,
    /* Top */    3, 2, 6, 3, 6, 7,
    /* Bottom */ 0, 4, 5, 0, 5, 1
};

static Mesh cube_mesh = {
    cube_vertices, 8,
    cube_indices, 36,
    14  /* Yellow */
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * DEMO: SPINNING CUBE
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

void gpu_demo_frame(void) {
    gpu_frame++;
    
    /* Clear screen */
    vga_clear(0);
    gpu_clear_zbuffer();
    
    /* Create rotation matrix */
    Mat3 rot_y, rot_x, rot;
    mat3_rot_y(&rot_y, gpu_frame);
    mat3_rot_x(&rot_x, gpu_frame / 2);
    
    /* Combine rotations (simplified) */
    rot = rot_y;  /* For demo, just Y rotation */
    
    /* Position */
    Vec3 pos = { 0, 0, 0 };
    
    /* Draw cube */
    gpu_draw_mesh(&cube_mesh, &rot, pos);
    
    /* Draw axes */
    Vec3 origin = { 0, 0, 0 };
    Vec3 x_axis = { INT_TO_FP(2), 0, 0 };
    Vec3 y_axis = { 0, INT_TO_FP(2), 0 };
    Vec3 z_axis = { 0, 0, INT_TO_FP(2) };
    
    gpu_draw_line_3d(origin, x_axis, 4);   /* Red = X */
    gpu_draw_line_3d(origin, y_axis, 2);   /* Green = Y */
    gpu_draw_line_3d(origin, z_axis, 1);   /* Blue = Z */
    
    /* Frame counter */
    vga_put_pixel(5, 5, 15);  /* Activity indicator */
}

void gpu_run_demo(void) {
    vga_init();
    vga_init_palette();
    init_heap();
    
    while (1) {
        gpu_demo_frame();
        vga_wait_vsync();
    }
}

#endif /* FRAY_GPU_C */
""";
        
        writeFile(OUTPUT_DIR + "/gpu.c", gpu);
    }

    private static void buildMeshData() throws IOException {
        System.out.println("   [3/3] Generating meshes.c...");
        
        String meshes = """
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * FRAY-MESHES: 3D MODEL DATA
 * Generated by Fraymus - Gen 145
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#ifndef FRAY_MESHES_C
#define FRAY_MESHES_C

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PYRAMID (4 vertices, 6 triangles)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

static Vec3 pyramid_vertices[5] = {
    { 0,           INT_TO_FP(1), 0 },            /* Top */
    { -FP_ONE,    -FP_ONE,      -FP_ONE },       /* Base corners */
    {  FP_ONE,    -FP_ONE,      -FP_ONE },
    {  FP_ONE,    -FP_ONE,       FP_ONE },
    { -FP_ONE,    -FP_ONE,       FP_ONE }
};

static int pyramid_indices[18] = {
    0, 1, 2,  /* Front face */
    0, 2, 3,  /* Right face */
    0, 3, 4,  /* Back face */
    0, 4, 1,  /* Left face */
    1, 3, 2,  /* Base triangle 1 */
    1, 4, 3   /* Base triangle 2 */
};

static Mesh pyramid_mesh = {
    pyramid_vertices, 5,
    pyramid_indices, 18,
    10  /* Light green */
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PHI RECTANGLE (Golden ratio proportions)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#define PHI_SCALE 414  /* 1.618 * 256 â‰ˆ 414 */

static Vec3 phi_rect_vertices[4] = {
    { -PHI_SCALE, -FP_ONE, 0 },
    {  PHI_SCALE, -FP_ONE, 0 },
    {  PHI_SCALE,  FP_ONE, 0 },
    { -PHI_SCALE,  FP_ONE, 0 }
};

static int phi_rect_indices[6] = {
    0, 1, 2,
    0, 2, 3
};

static Mesh phi_rect_mesh = {
    phi_rect_vertices, 4,
    phi_rect_indices, 6,
    6  /* Brown/Gold */
};

#endif /* FRAY_MESHES_C */
""";
        
        writeFile(OUTPUT_DIR + "/meshes.c", meshes);
    }

    private static void writeFile(String path, String content) throws IOException {
        Path filePath = Paths.get(path);
        Files.createDirectories(filePath.getParent());
        Files.writeString(filePath, content);
        System.out.println("      â†’ " + path);
    }
}
