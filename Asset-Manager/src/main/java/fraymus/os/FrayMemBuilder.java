package fraymus.os;

import java.io.*;
import java.nio.file.*;

/**
 * ğŸ§  FRAY MEMORY BUILDER - Gen 145
 * "We tell the CPU that the Disk is RAM."
 * 
 * The Infinite Lie - Virtual Memory System
 * 
 * Features:
 *   - x86 Paging initialization (CR3 register)
 *   - 4KB page frames
 *   - Identity mapping for kernel space
 *   - Demand paging with page fault handler
 *   - 4GB virtual address space (32-bit)
 * 
 * The CPU believes it has infinite RAM.
 * When it asks for memory that doesn't exist,
 * we catch the fault and conjure it from the void.
 * 
 * "The Machine hallucinates memory."
 */
public class FrayMemBuilder {

    private static final String OUTPUT_DIR = "fraynix_src";

    public static void main(String[] args) {
        System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘  ğŸ§  FRAY MEMORY BUILDER - Gen 145                             â•‘");
        System.out.println("â•‘  Virtual Memory Manager (The Infinite Lie)                   â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        System.out.println();
        
        try {
            Files.createDirectories(Paths.get(OUTPUT_DIR));
            
            System.out.println("âš¡ Generating virtual memory system...");
            
            buildPagingSystem();
            buildPagingAssembly();
            buildHeapManager();
            
            System.out.println();
            System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            System.out.println("â•‘  âœ… VIRTUAL MEMORY SYSTEM INSTALLED                           â•‘");
            System.out.println("â•‘                                                               â•‘");
            System.out.println("â•‘  Output: fraynix_src/paging.c                                â•‘");
            System.out.println("â•‘          fraynix_src/paging.asm                              â•‘");
            System.out.println("â•‘          fraynix_src/heap.c                                  â•‘");
            System.out.println("â•‘                                                               â•‘");
            System.out.println("â•‘  Virtual Space: 4 GB (0x00000000 - 0xFFFFFFFF)               â•‘");
            System.out.println("â•‘  Page Size:     4 KB                                         â•‘");
            System.out.println("â•‘  Page Tables:   1024 entries each                            â•‘");
            System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            
        } catch (IOException e) {
            System.err.println("âŒ BUILD FAILED: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void buildPagingSystem() throws IOException {
        System.out.println("   [1/3] Generating paging.c...");
        
        String paging = """
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * FRAY-MEM: VIRTUAL MEMORY MANAGER
 * Generated by Fraymus - Gen 145
 * 
 * x86 32-bit Paging Implementation
 * 
 * Structure:
 *   Page Directory (1024 entries Ã— 4 bytes = 4KB)
 *     â””â”€â”€ Page Table (1024 entries Ã— 4 bytes = 4KB)
 *           â””â”€â”€ Page Frame (4KB physical memory)
 * 
 * Virtual Address Format (32-bit):
 *   [31:22] Directory Index (10 bits) â†’ 1024 entries
 *   [21:12] Table Index (10 bits)     â†’ 1024 entries
 *   [11:0]  Page Offset (12 bits)     â†’ 4096 bytes
 * 
 * "The CPU sees 4GB. We have 64MB. Math is our ally."
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#ifndef FRAY_PAGING_C
#define FRAY_PAGING_C

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PAGE TABLE STRUCTURES
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#define PAGE_SIZE       4096
#define PAGES_PER_TABLE 1024
#define TABLES_PER_DIR  1024

#define PAGE_PRESENT    0x001
#define PAGE_WRITABLE   0x002
#define PAGE_USER       0x004
#define PAGE_ACCESSED   0x020
#define PAGE_DIRTY      0x040

/* Page directory and first page table (4KB aligned) */
static unsigned int page_directory[1024] __attribute__((aligned(4096)));
static unsigned int kernel_page_table[1024] __attribute__((aligned(4096)));

/* Free frame bitmap (1 bit per 4KB frame) */
/* Supports up to 128MB physical memory */
#define MAX_FRAMES (128 * 1024 * 1024 / PAGE_SIZE)
static unsigned char frame_bitmap[MAX_FRAMES / 8];

/* Statistics */
static unsigned int pages_allocated = 0;
static unsigned int page_faults = 0;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ASSEMBLY HOOKS (defined in paging.asm)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

extern void load_page_directory(unsigned int* pd);
extern void enable_paging(void);
extern void flush_tlb(void);
extern unsigned int get_faulting_address(void);

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * FRAME ALLOCATOR
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

static int first_free_frame(void) {
    for (unsigned int i = 0; i < MAX_FRAMES / 8; i++) {
        if (frame_bitmap[i] != 0xFF) {
            for (int j = 0; j < 8; j++) {
                if (!(frame_bitmap[i] & (1 << j))) {
                    return i * 8 + j;
                }
            }
        }
    }
    return -1;  /* Out of memory */
}

static void set_frame(unsigned int frame) {
    frame_bitmap[frame / 8] |= (1 << (frame % 8));
}

static void clear_frame(unsigned int frame) {
    frame_bitmap[frame / 8] &= ~(1 << (frame % 8));
}

static unsigned int alloc_frame(void) {
    int frame = first_free_frame();
    if (frame < 0) {
        kprint_color("  OUT OF PHYSICAL MEMORY!\\n", 0x0C);
        return 0;
    }
    set_frame(frame);
    pages_allocated++;
    return frame * PAGE_SIZE;
}

static void free_frame(unsigned int phys_addr) {
    unsigned int frame = phys_addr / PAGE_SIZE;
    clear_frame(frame);
    pages_allocated--;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PAGE TABLE MANAGEMENT
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

static unsigned int* get_page_table(unsigned int dir_index, int create) {
    if (page_directory[dir_index] & PAGE_PRESENT) {
        return (unsigned int*)(page_directory[dir_index] & 0xFFFFF000);
    }
    
    if (!create) return 0;
    
    /* Allocate new page table */
    unsigned int table_phys = alloc_frame();
    if (!table_phys) return 0;
    
    /* Clear new table */
    unsigned int* table = (unsigned int*)table_phys;
    for (int i = 0; i < 1024; i++) {
        table[i] = 0;
    }
    
    /* Add to directory */
    page_directory[dir_index] = table_phys | PAGE_PRESENT | PAGE_WRITABLE | PAGE_USER;
    
    return table;
}

void map_page(unsigned int virt, unsigned int phys, unsigned int flags) {
    unsigned int dir_idx = virt >> 22;
    unsigned int table_idx = (virt >> 12) & 0x3FF;
    
    unsigned int* table = get_page_table(dir_idx, 1);
    if (table) {
        table[table_idx] = (phys & 0xFFFFF000) | (flags & 0xFFF) | PAGE_PRESENT;
        flush_tlb();
    }
}

void unmap_page(unsigned int virt) {
    unsigned int dir_idx = virt >> 22;
    unsigned int table_idx = (virt >> 12) & 0x3FF;
    
    unsigned int* table = get_page_table(dir_idx, 0);
    if (table) {
        if (table[table_idx] & PAGE_PRESENT) {
            free_frame(table[table_idx] & 0xFFFFF000);
            table[table_idx] = 0;
            flush_tlb();
        }
    }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PAGE FAULT HANDLER
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

void page_fault_handler(unsigned int error_code) {
    unsigned int faulting_addr = get_faulting_address();
    page_faults++;
    
    kprint_color("\\n  âš¡ PAGE FAULT #", 0x0E);
    kprint_int(page_faults);
    kprint(" @ ");
    kprint_hex(faulting_addr);
    
    /* Decode error code */
    int present = error_code & 0x1;
    int write = error_code & 0x2;
    int user = error_code & 0x4;
    
    if (present) {
        /* Page protection violation */
        kprint_color(" [PROTECTION VIOLATION]\\n", 0x0C);
        /* In real OS: kill the process */
        while(1);
    }
    
    /* Page not present - allocate on demand */
    kprint_color(" [ALLOCATING]\\n", 0x0A);
    
    unsigned int new_frame = alloc_frame();
    if (new_frame) {
        map_page(faulting_addr & 0xFFFFF000, new_frame, PAGE_WRITABLE | PAGE_USER);
        kprint("    â†’ Mapped to physical ");
        kprint_hex(new_frame);
        kprint("\\n");
    } else {
        kprint_color("    â†’ ALLOCATION FAILED!\\n", 0x0C);
        while(1);
    }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * INITIALIZATION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

void init_paging(void) {
    /* Clear frame bitmap */
    for (unsigned int i = 0; i < MAX_FRAMES / 8; i++) {
        frame_bitmap[i] = 0;
    }
    
    /* Mark first 4MB as used (kernel space) */
    for (unsigned int i = 0; i < 1024; i++) {
        set_frame(i);
    }
    
    /* Identity map first 4MB (kernel) */
    for (unsigned int i = 0; i < 1024; i++) {
        kernel_page_table[i] = (i * PAGE_SIZE) | PAGE_PRESENT | PAGE_WRITABLE;
    }
    
    /* Set up page directory */
    for (unsigned int i = 0; i < 1024; i++) {
        page_directory[i] = PAGE_WRITABLE;  /* Not present */
    }
    
    /* Point first directory entry to kernel page table */
    page_directory[0] = ((unsigned int)kernel_page_table) | PAGE_PRESENT | PAGE_WRITABLE;
    
    /* Load and enable paging */
    load_page_directory(page_directory);
    enable_paging();
    
    pages_allocated = 1024;  /* Kernel pages */
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * STATUS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

void paging_status(void) {
    kprint_color("\\n  VIRTUAL MEMORY STATUS\\n", 0x0B);
    kprint("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n");
    kprint("  Pages allocated: ");
    kprint_int(pages_allocated);
    kprint(" (");
    kprint_int(pages_allocated * 4);
    kprint(" KB)\\n");
    kprint("  Page faults:     ");
    kprint_int(page_faults);
    kprint("\\n");
    kprint("  Virtual space:   4 GB\\n");
    kprint("\\n");
}

#endif /* FRAY_PAGING_C */
""";
        
        writeFile(OUTPUT_DIR + "/paging.c", paging);
    }

    private static void buildPagingAssembly() throws IOException {
        System.out.println("   [2/3] Generating paging.asm...");
        
        String asm = """
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
; FRAY-MEM: PAGING ASSEMBLY ROUTINES
; Generated by Fraymus - Gen 145
; â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bits 32
section .text

global load_page_directory
global enable_paging
global flush_tlb
global get_faulting_address

; Load page directory address into CR3
load_page_directory:
    push ebp
    mov ebp, esp
    mov eax, [ebp + 8]    ; Get pointer argument
    mov cr3, eax          ; Load into CR3
    pop ebp
    ret

; Enable paging by setting bit 31 of CR0
enable_paging:
    push ebp
    mov ebp, esp
    mov eax, cr0
    or eax, 0x80000000    ; Set PG bit
    mov cr0, eax
    pop ebp
    ret

; Flush TLB by reloading CR3
flush_tlb:
    push eax
    mov eax, cr3
    mov cr3, eax
    pop eax
    ret

; Get faulting address from CR2
get_faulting_address:
    mov eax, cr2
    ret

; Page fault handler wrapper
global page_fault_wrapper
extern page_fault_handler

page_fault_wrapper:
    pusha                  ; Save all registers
    mov eax, [esp + 32]    ; Get error code
    push eax
    call page_fault_handler
    add esp, 4
    popa
    add esp, 4             ; Remove error code
    iret
""";
        
        writeFile(OUTPUT_DIR + "/paging.asm", asm);
    }

    private static void buildHeapManager() throws IOException {
        System.out.println("   [3/3] Generating heap.c...");
        
        String heap = """
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * FRAY-HEAP: DYNAMIC MEMORY ALLOCATOR
 * Generated by Fraymus - Gen 145
 * 
 * Simple first-fit allocator with coalescing
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#ifndef FRAY_HEAP_C
#define FRAY_HEAP_C

#define HEAP_START 0x00400000  /* 4MB mark */
#define HEAP_SIZE  0x00400000  /* 4MB heap */

typedef struct block_header {
    unsigned int size;
    unsigned int is_free;
    struct block_header* next;
} block_header_t;

static block_header_t* heap_start = 0;
static unsigned int heap_end = 0;

void init_heap(void) {
    heap_start = (block_header_t*)HEAP_START;
    heap_start->size = HEAP_SIZE - sizeof(block_header_t);
    heap_start->is_free = 1;
    heap_start->next = 0;
    heap_end = HEAP_START + HEAP_SIZE;
}

void* kmalloc(unsigned int size) {
    /* Align to 4 bytes */
    size = (size + 3) & ~3;
    
    block_header_t* current = heap_start;
    
    while (current) {
        if (current->is_free && current->size >= size) {
            /* Split block if large enough */
            if (current->size > size + sizeof(block_header_t) + 16) {
                block_header_t* new_block = (block_header_t*)((char*)current + sizeof(block_header_t) + size);
                new_block->size = current->size - size - sizeof(block_header_t);
                new_block->is_free = 1;
                new_block->next = current->next;
                
                current->size = size;
                current->next = new_block;
            }
            
            current->is_free = 0;
            return (void*)((char*)current + sizeof(block_header_t));
        }
        current = current->next;
    }
    
    return 0;  /* Out of memory */
}

void kfree(void* ptr) {
    if (!ptr) return;
    
    block_header_t* header = (block_header_t*)((char*)ptr - sizeof(block_header_t));
    header->is_free = 1;
    
    /* Coalesce with next block if free */
    if (header->next && header->next->is_free) {
        header->size += sizeof(block_header_t) + header->next->size;
        header->next = header->next->next;
    }
}

void* krealloc(void* ptr, unsigned int size) {
    if (!ptr) return kmalloc(size);
    
    block_header_t* header = (block_header_t*)((char*)ptr - sizeof(block_header_t));
    
    if (header->size >= size) return ptr;
    
    void* new_ptr = kmalloc(size);
    if (new_ptr) {
        /* Copy old data */
        char* src = (char*)ptr;
        char* dst = (char*)new_ptr;
        for (unsigned int i = 0; i < header->size; i++) {
            dst[i] = src[i];
        }
        kfree(ptr);
    }
    return new_ptr;
}

#endif /* FRAY_HEAP_C */
""";
        
        writeFile(OUTPUT_DIR + "/heap.c", heap);
    }

    private static void writeFile(String path, String content) throws IOException {
        Path filePath = Paths.get(path);
        Files.createDirectories(filePath.getParent());
        Files.writeString(filePath, content);
        System.out.println("      â†’ " + path);
    }
}
