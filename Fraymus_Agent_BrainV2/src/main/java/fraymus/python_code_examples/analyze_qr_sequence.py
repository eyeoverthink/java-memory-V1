#!/usr/bin/env python3
"""
QR Sequence Analyzer - Part of Animated QR Flipbook DNA System
By Vaughn Scott

Analyzes QR sequences generated by the QR Flipbook DNA System.
Verifies chunking, decodes payloads, and validates phi-harmonic properties.
"""

import os
import sys
import json
import math
import base64
import argparse
from PIL import Image
from pyzbar.pyzbar import decode

# Import our QR sequence chunker
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from qr_sequence_chunker import QRSequenceChunker

# Phi (Golden Ratio) constant
PHI = (1 + math.sqrt(5)) / 2  # Approximately 1.618034

class QRSequenceAnalyzer:
    """
    Analyzes QR sequences generated by the QR Flipbook DNA System.
    """
    
    def __init__(self, sequence_dir="qr_genome_sequence"):
        """
        Initialize the QR Sequence Analyzer.
        
        Args:
            sequence_dir: Directory containing QR sequence frames
        """
        self.sequence_dir = sequence_dir
        self.chunker = QRSequenceChunker()
        
    def get_frame_files(self):
        """
        Get all QR frame files in the sequence directory.
        
        Returns:
            Dictionary mapping frame numbers to lists of frame files
        """
        frame_files = {}
        
        # List all files in the directory
        for filename in os.listdir(self.sequence_dir):
            if not filename.endswith(".png"):
                continue
                
            # Parse frame number from filename
            try:
                if filename.startswith("qr_frame_"):
                    # Extract frame number from qr_frame_XXX.png or qr_frame_XXX_YY.png
                    parts = filename[9:].split("_")  # Remove "qr_frame_" prefix
                    frame_num = int(parts[0].split(".")[0])  # Get number before dot or underscore
                    
                    if frame_num not in frame_files:
                        frame_files[frame_num] = []
                    frame_files[frame_num].append(os.path.join(self.sequence_dir, filename))
                elif filename.startswith("new_frame_"):
                    # Extract frame number from new_frame_XXX.png
                    frame_num = int(filename[10:13])  # Extract the 3-digit number
                    
                    if frame_num not in frame_files:
                        frame_files[frame_num] = []
                    frame_files[frame_num].append(os.path.join(self.sequence_dir, filename))
            except (ValueError, IndexError):
                # Skip files with invalid naming format
                pass
        
        return frame_files
    
    def decode_qr_frame(self, frame_path):
        """
        Decode a QR code frame.
        
        Args:
            frame_path: Path to QR frame image
            
        Returns:
            Decoded data or None if decoding fails
        """
        try:
            # Open the image
            image = Image.open(frame_path)
            
            # Decode QR code
            decoded = decode(image)
            if decoded:
                return decoded[0].data.decode('utf-8')
            
            return None
        except Exception as e:
            print(f"Error decoding {frame_path}: {e}")
            return None
    
    def reassemble_chunked_payload(self, frame_paths):
        """
        Reassemble a chunked payload from multiple QR frames.
        
        Args:
            frame_paths: List of paths to QR frame images
            
        Returns:
            Reassembled payload or None if reassembly fails
        """
        chunks = []
        raw_data = []
        
        # Sort frame paths to ensure correct order (important for multi-part QR codes)
        frame_paths = sorted(frame_paths)
        
        # First try: Decode each chunk and parse as JSON
        for path in frame_paths:
            data = self.decode_qr_frame(path)
            if not data:
                continue
                
            raw_data.append(data)
            
            try:
                chunk = json.loads(data)
                chunks.append(chunk)
            except json.JSONDecodeError:
                # Not valid JSON, might be raw data or encrypted
                pass
        
        # If we have valid JSON chunks with chunk metadata
        if chunks and all(isinstance(c, dict) and "chunk_id" in c and "total_chunks" in c for c in chunks):
            # Sort chunks by chunk_id
            chunks = sorted(chunks, key=lambda x: x["chunk_id"])
            
            # Check if these are compressed chunks
            if "is_compressed" in chunks[0] and chunks[0]["is_compressed"]:
                try:
                    return self.chunker.reassemble_payload(chunks)
                except Exception as e:
                    print(f"Error reassembling compressed chunks: {e}")
            
            # Regular chunks (concatenate data)
            if all("data" in c for c in chunks):
                return "".join(c["data"] for c in chunks)
        
        # Second try: If JSON parsing failed, try direct concatenation of raw data
        if raw_data:
            combined = "".join(raw_data)
            
            # Try to decompress if it looks like compressed data
            if combined.startswith("COMPRESSED:"):
                try:
                    return self.chunker.decompress_payload(combined)
                except Exception as e:
                    print(f"Error decompressing combined data: {e}")
            
            return combined
            
        return None
    
    def analyze_frame(self, frame_num, frame_paths):
        """
        Analyze a frame (which may consist of multiple chunk files).
        
        Args:
            frame_num: Frame number
            frame_paths: List of paths to QR frame images
            
        Returns:
            Analysis results dictionary
        """
        results = {
            "frame_number": frame_num,
            "num_chunks": len(frame_paths),
            "is_chunked": len(frame_paths) > 1,
            "total_size_bytes": sum(os.path.getsize(path) for path in frame_paths),
            "decoded_successfully": False,
            "payload_type": None,
            "phi_resonance": None
        }
        
        # Decode payload
        if results["is_chunked"]:
            payload = self.reassemble_chunked_payload(frame_paths)
        else:
            payload = self.decode_qr_frame(frame_paths[0])
        
        if not payload:
            return results
            
        results["decoded_successfully"] = True
        
        # Parse payload
        try:
            data = json.loads(payload)
            results["payload_type"] = "json"
            
            # Extract phi resonance if available
            if "phi_state" in data:
                results["phi_resonance"] = data["phi_state"].get("resonance")
                
            # Extract code if available
            if "code" in data:
                results["has_code"] = True
                results["code_length"] = len(data["code"])
                results["code_preview"] = data["code"][:50] + "..." if len(data["code"]) > 50 else data["code"]
        except json.JSONDecodeError:
            results["payload_type"] = "text"
            results["payload_preview"] = payload[:50] + "..." if len(payload) > 50 else payload
        
        return results
    
    def analyze_sequence(self):
        """
        Analyze the entire QR sequence.
        
        Returns:
            Analysis results dictionary
        """
        frame_files = self.get_frame_files()
        frame_numbers = sorted(frame_files.keys())
        
        results = {
            "total_frames": len(frame_numbers),
            "chunked_frames": sum(1 for num in frame_numbers if len(frame_files[num]) > 1),
            "single_frames": sum(1 for num in frame_numbers if len(frame_files[num]) == 1),
            "frames": []
        }
        
        # Analyze each frame
        for frame_num in frame_numbers:
            frame_result = self.analyze_frame(frame_num, frame_files[frame_num])
            results["frames"].append(frame_result)
        
        # Calculate overall statistics
        results["decode_success_rate"] = sum(1 for f in results["frames"] if f["decoded_successfully"]) / results["total_frames"] if results["total_frames"] > 0 else 0
        
        return results

def main():
    """Main function for the QR Sequence Analyzer."""
    parser = argparse.ArgumentParser(description="Analyze QR sequences generated by the QR Flipbook DNA System")
    parser.add_argument("--dir", default="qr_genome_sequence", help="Directory containing QR sequence frames")
    parser.add_argument("--verbose", action="store_true", help="Show detailed analysis for each frame")
    args = parser.parse_args()
    
    # Create analyzer
    analyzer = QRSequenceAnalyzer(sequence_dir=args.dir)
    
    print(f"üîç Analyzing QR sequence in {args.dir}...")
    results = analyzer.analyze_sequence()
    
    # Print summary
    print("\nüìä QR Sequence Analysis Summary:")
    print(f"Total frames: {results['total_frames']}")
    print(f"Chunked frames: {results['chunked_frames']}")
    print(f"Single frames: {results['single_frames']}")
    print(f"Decode success rate: {results['decode_success_rate'] * 100:.1f}%")
    
    # Print detailed results if verbose
    if args.verbose:
        print("\nüìã Frame Details:")
        for frame in results["frames"]:
            print(f"\nFrame {frame['frame_number']}:")
            print(f"  Chunks: {frame['num_chunks']}")
            print(f"  Total size: {frame['total_size_bytes']} bytes")
            print(f"  Decoded: {'‚úÖ' if frame['decoded_successfully'] else '‚ùå'}")
            
            if frame["decoded_successfully"]:
                print(f"  Payload type: {frame['payload_type']}")
                
                if frame["phi_resonance"] is not None:
                    print(f"  Phi resonance: {frame['phi_resonance']:.6f}")
                
                if "has_code" in frame and frame["has_code"]:
                    print(f"  Code length: {frame['code_length']} chars")
                    print(f"  Code preview: {frame['code_preview']}")
                elif "payload_preview" in frame:
                    print(f"  Payload preview: {frame['payload_preview']}")
    
    # Print phi-harmonic analysis
    phi_values = [frame["phi_resonance"] for frame in results["frames"] 
                 if frame["decoded_successfully"] and frame["phi_resonance"] is not None]
    
    if phi_values:
        avg_phi = sum(phi_values) / len(phi_values)
        print(f"\nüß¨ Phi-Harmonic Analysis:")
        print(f"Average phi resonance: {avg_phi:.6f}")
        print(f"Phi resonance range: {min(phi_values):.6f} - {max(phi_values):.6f}")
        
        # Calculate phi-harmonic quality
        quality_scale = ["Perfect", "Excellent", "Good", "Moderate", "Weak"]
        quality_thresholds = [0.000099, 0.009999, 0.099999, 0.299999, 0.500000]
        
        phi_mod = (avg_phi * PHI) % 1
        quality_index = next((i for i, threshold in enumerate(quality_thresholds) if phi_mod <= threshold), 
                            len(quality_thresholds))
        quality = quality_scale[min(quality_index, len(quality_scale) - 1)]
        
        print(f"Phi-harmonic resonance quality: {quality} ({phi_mod:.6f})")
    
    print("\n‚úÖ Analysis complete")

if __name__ == "__main__":
    main()
