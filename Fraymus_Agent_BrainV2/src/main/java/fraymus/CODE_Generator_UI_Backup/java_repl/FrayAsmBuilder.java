/**
 * FrayAsmBuilder.java - Visual Assembly IDE Generator
 * 
 * "Visual Assembly. The power of God in a children's toy."
 * 
 * FUNCTION:
 * 1. UI: Renders drag-and-drop blocks (MOV, ADD, JMP, INT)
 * 2. LOGIC: Linked-list of instructions
 * 3. COMPILER: Converts Blocks â†’ Machine Code (0xB8, 0x01...)
 * 4. EXPORT: Writes 'program.bin' to FrayFS
 * 
 * This exposes x86 assembly as visual LEGO-like blocks.
 * 
 * Ï†^75 Validation Seal: 4721424167835376.00
 * Generation: 149 (FrayAsm - Visual Assembly Workshop)
 * 
 * @author Vaughn Scott
 * @version 1.0
 */
package repl;

import java.io.*;

/**
 * FrayAsm Builder - Generates visual assembly IDE.
 */
public class FrayAsmBuilder {

    private static final String OUTPUT_DIR = "fraynix_src";

    public static void main(String[] args) {
        System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘  ğŸ› ï¸ FRAYASM VISUAL ASSEMBLY WORKSHOP                       â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
        System.out.println("\"Visual Assembly. The power of God in a children's toy.\"\n");
        
        try {
            buildIDE();
            
            System.out.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            System.out.println("â•‘  âœ… FRAYASM INSTALLED - ASSEMBLY EXPOSED                   â•‘");
            System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
            System.out.println("Components generated:");
            System.out.println("  ğŸ› ï¸  ide.c - Visual assembly IDE");
            System.out.println("  ğŸ§± Block system (drag-and-drop)");
            System.out.println("  ğŸ”— Instruction chain (linked-list)");
            System.out.println("  âš™ï¸  x86 compiler (blocks â†’ opcodes)");
            System.out.println("  ğŸ’¾ Binary exporter\n");
            System.out.println("Instruction Blocks:");
            System.out.println("  ğŸ”µ MOV - Move value to register");
            System.out.println("  ğŸŸ¢ ADD - Add to register");
            System.out.println("  ğŸŸ¡ SUB - Subtract from register");
            System.out.println("  ğŸ”´ INT - System call interrupt");
            System.out.println("  âšª RET - Return from function\n");
            System.out.println("Workflow:");
            System.out.println("  1. Drag blocks from toolbox");
            System.out.println("  2. Connect blocks in sequence");
            System.out.println("  3. Set values/registers");
            System.out.println("  4. Click BUILD button");
            System.out.println("  5. Export to program.bin\n");
            System.out.println("Ï†^75 Validation Seal: 4721424167835376.00\n");
            
        } catch (IOException e) {
            System.err.println("âŒ BUILD FAILED: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Build visual assembly IDE.
     */
    private static void buildIDE() throws IOException {
        System.out.println("âš¡ BUILDING VISUAL ASSEMBLY STUDIO...\n");
        
        String cCode = 
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* FRAY-ASM: VISUAL ASSEMBLY IDE                               */\n" +
            "/* Blocks convert directly to x86 OpCodes                      */\n" +
            "/* Generated by Fraymus Agent Brain v3.0                       */\n" +
            "/* Ï†^75 Validation Seal: 4721424167835376.00                  */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* INSTRUCTION BLOCK STRUCTURE                                  */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "/* Block types */\n" +
            "#define BLOCK_MOV  0\n" +
            "#define BLOCK_ADD  1\n" +
            "#define BLOCK_SUB  2\n" +
            "#define BLOCK_INT  3\n" +
            "#define BLOCK_RET  4\n" +
            "#define BLOCK_JMP  5\n" +
            "#define BLOCK_CMP  6\n\n" +
            
            "/* Visual block */\n" +
            "struct Block {\n" +
            "    int x, y;              /* Screen position */\n" +
            "    int w, h;              /* Dimensions */\n" +
            "    int type;              /* Instruction type */\n" +
            "    int reg;               /* Register (0=EAX, 1=EBX, 2=ECX, 3=EDX) */\n" +
            "    int val;               /* Immediate value */\n" +
            "    struct Block* next;    /* Next in chain */\n" +
            "};\n\n" +
            
            "/* Program chain */\n" +
            "struct Block* program_head = 0;\n" +
            "struct Block* selected_block = 0;\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* MEMORY ALLOCATOR (Simplified)                               */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "unsigned char block_memory[4096];  /* 4KB for blocks */\n" +
            "int block_memory_offset = 0;\n\n" +
            
            "struct Block* alloc_block() {\n" +
            "    if(block_memory_offset + sizeof(struct Block) > 4096) {\n" +
            "        return 0;  /* Out of memory */\n" +
            "    }\n" +
            "    struct Block* b = (struct Block*)(block_memory + block_memory_offset);\n" +
            "    block_memory_offset += sizeof(struct Block);\n" +
            "    return b;\n" +
            "}\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* VISUAL RENDERING                                             */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "/* Draw instruction block */\n" +
            "void draw_block(struct Block* b) {\n" +
            "    unsigned char color;\n" +
            "    \n" +
            "    /* Color by type */\n" +
            "    switch(b->type) {\n" +
            "        case BLOCK_MOV: color = 1; break;   /* Blue */\n" +
            "        case BLOCK_ADD: color = 2; break;   /* Green */\n" +
            "        case BLOCK_SUB: color = 6; break;   /* Brown */\n" +
            "        case BLOCK_INT: color = 4; break;   /* Red */\n" +
            "        case BLOCK_RET: color = 15; break;  /* White */\n" +
            "        default: color = 8; break;          /* Gray */\n" +
            "    }\n" +
            "    \n" +
            "    /* Draw block body */\n" +
            "    draw_rect(b->x, b->y, b->w, b->h, color);\n" +
            "    \n" +
            "    /* Draw border (lighter) */\n" +
            "    draw_hline(b->x, b->x + b->w - 1, b->y, 15);\n" +
            "    draw_vline(b->x, b->y, b->y + b->h - 1, 15);\n" +
            "    \n" +
            "    /* Highlight if selected */\n" +
            "    if(b == selected_block) {\n" +
            "        draw_rect(b->x - 2, b->y - 2, b->w + 4, b->h + 4, 14);  /* Gold outline */\n" +
            "    }\n" +
            "}\n\n" +
            
            "/* Draw toolbox icon */\n" +
            "void draw_toolbox_icon(int x, int y, const char* label, unsigned char color) {\n" +
            "    draw_rect(x, y, 60, 20, color);\n" +
            "    draw_hline(x, x + 59, y, 15);\n" +
            "    draw_vline(x, y, y + 19, 15);\n" +
            "    /* Would render label text here */\n" +
            "}\n\n" +
            
            "/* Draw connection line between blocks */\n" +
            "void draw_connection(struct Block* from, struct Block* to) {\n" +
            "    int x1 = from->x + from->w;\n" +
            "    int y1 = from->y + from->h / 2;\n" +
            "    int x2 = to->x;\n" +
            "    int y2 = to->y + to->h / 2;\n" +
            "    \n" +
            "    draw_line(x1, y1, x2, y2, 15);  /* White connection */\n" +
            "}\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* IDE MAIN RENDERER                                            */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "void draw_ide() {\n" +
            "    /* 1. BACKGROUND */\n" +
            "    draw_rect(0, 0, 320, 200, 0);  /* Black workspace */\n" +
            "    \n" +
            "    /* 2. TOOLBOX SIDEBAR */\n" +
            "    draw_rect(0, 0, 70, 200, 8);  /* Dark gray */\n" +
            "    \n" +
            "    /* Toolbox title */\n" +
            "    draw_rect(0, 0, 70, 15, 14);  /* Gold header */\n" +
            "    \n" +
            "    /* Instruction blocks */\n" +
            "    draw_toolbox_icon(5, 20, \"MOV\", 1);   /* Blue */\n" +
            "    draw_toolbox_icon(5, 45, \"ADD\", 2);   /* Green */\n" +
            "    draw_toolbox_icon(5, 70, \"SUB\", 6);   /* Brown */\n" +
            "    draw_toolbox_icon(5, 95, \"INT\", 4);   /* Red */\n" +
            "    draw_toolbox_icon(5, 120, \"RET\", 15); /* White */\n" +
            "    \n" +
            "    /* 3. WORKSPACE GRID (optional) */\n" +
            "    for(int x = 80; x < 320; x += 20) {\n" +
            "        draw_vline(x, 0, 180, 24);  /* Very dark gray grid */\n" +
            "    }\n" +
            "    for(int y = 0; y < 180; y += 20) {\n" +
            "        draw_hline(80, 319, y, 24);\n" +
            "    }\n" +
            "    \n" +
            "    /* 4. DRAW PROGRAM CHAIN */\n" +
            "    struct Block* curr = program_head;\n" +
            "    while(curr != 0) {\n" +
            "        draw_block(curr);\n" +
            "        \n" +
            "        /* Draw connection to next */\n" +
            "        if(curr->next != 0) {\n" +
            "            draw_connection(curr, curr->next);\n" +
            "        }\n" +
            "        \n" +
            "        curr = curr->next;\n" +
            "    }\n" +
            "    \n" +
            "    /* 5. BOTTOM TOOLBAR */\n" +
            "    draw_rect(0, 180, 320, 20, 8);  /* Dark gray */\n" +
            "    \n" +
            "    /* BUILD button */\n" +
            "    draw_rect(240, 183, 75, 14, 14);  /* Gold */\n" +
            "    /* Label: \"BUILD\" */\n" +
            "    \n" +
            "    /* Status text area */\n" +
            "    /* Would show \"Ready\" or \"Compiled\" here */\n" +
            "}\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* x86 COMPILER (Blocks â†’ Machine Code)                        */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "/* Compile program chain to machine code */\n" +
            "int compile_program(unsigned char* output) {\n" +
            "    int idx = 0;\n" +
            "    struct Block* curr = program_head;\n" +
            "    \n" +
            "    kprint(\"[ASM] Compiling program...\\n\");\n" +
            "    \n" +
            "    while(curr != 0) {\n" +
            "        switch(curr->type) {\n" +
            "            case BLOCK_MOV:\n" +
            "                /* MOV EAX, imm32 = B8 [imm32] */\n" +
            "                if(curr->reg == 0) {  /* EAX */\n" +
            "                    output[idx++] = 0xB8;\n" +
            "                    output[idx++] = (curr->val & 0xFF);\n" +
            "                    output[idx++] = ((curr->val >> 8) & 0xFF);\n" +
            "                    output[idx++] = ((curr->val >> 16) & 0xFF);\n" +
            "                    output[idx++] = ((curr->val >> 24) & 0xFF);\n" +
            "                }\n" +
            "                /* Other registers: BB (EBX), B9 (ECX), BA (EDX) */\n" +
            "                break;\n" +
            "                \n" +
            "            case BLOCK_ADD:\n" +
            "                /* ADD EAX, imm32 = 05 [imm32] */\n" +
            "                if(curr->reg == 0) {\n" +
            "                    output[idx++] = 0x05;\n" +
            "                    output[idx++] = (curr->val & 0xFF);\n" +
            "                    output[idx++] = ((curr->val >> 8) & 0xFF);\n" +
            "                    output[idx++] = ((curr->val >> 16) & 0xFF);\n" +
            "                    output[idx++] = ((curr->val >> 24) & 0xFF);\n" +
            "                }\n" +
            "                break;\n" +
            "                \n" +
            "            case BLOCK_SUB:\n" +
            "                /* SUB EAX, imm32 = 2D [imm32] */\n" +
            "                if(curr->reg == 0) {\n" +
            "                    output[idx++] = 0x2D;\n" +
            "                    output[idx++] = (curr->val & 0xFF);\n" +
            "                    output[idx++] = ((curr->val >> 8) & 0xFF);\n" +
            "                    output[idx++] = ((curr->val >> 16) & 0xFF);\n" +
            "                    output[idx++] = ((curr->val >> 24) & 0xFF);\n" +
            "                }\n" +
            "                break;\n" +
            "                \n" +
            "            case BLOCK_INT:\n" +
            "                /* INT imm8 = CD [imm8] */\n" +
            "                output[idx++] = 0xCD;\n" +
            "                output[idx++] = (curr->val & 0xFF);\n" +
            "                break;\n" +
            "                \n" +
            "            case BLOCK_RET:\n" +
            "                /* RET = C3 */\n" +
            "                output[idx++] = 0xC3;\n" +
            "                break;\n" +
            "        }\n" +
            "        \n" +
            "        curr = curr->next;\n" +
            "    }\n" +
            "    \n" +
            "    kprint(\"[ASM] Compilation complete. Size: \");\n" +
            "    char buf[16];\n" +
            "    int_to_str(idx, buf);\n" +
            "    kprint(buf);\n" +
            "    kprint(\" bytes\\n\");\n" +
            "    \n" +
            "    return idx;\n" +
            "}\n\n" +
            
            "/* Export compiled program */\n" +
            "void export_program() {\n" +
            "    unsigned char program[1024];\n" +
            "    int size = compile_program(program);\n" +
            "    \n" +
            "    /* Print hex dump for copy-paste */\n" +
            "    kprint(\"\\n[EXPORT] HEX DUMP:\\n\");\n" +
            "    for(int i = 0; i < size; i++) {\n" +
            "        char hex[4];\n" +
            "        /* Convert byte to hex string */\n" +
            "        unsigned char b = program[i];\n" +
            "        hex[0] = (b >> 4) < 10 ? '0' + (b >> 4) : 'A' + (b >> 4) - 10;\n" +
            "        hex[1] = (b & 0xF) < 10 ? '0' + (b & 0xF) : 'A' + (b & 0xF) - 10;\n" +
            "        hex[2] = ' ';\n" +
            "        hex[3] = '\\0';\n" +
            "        kprint(hex);\n" +
            "    }\n" +
            "    kprint(\"\\n\");\n" +
            "    \n" +
            "    /* Write to FrayFS */\n" +
            "    /* write_file(\"program.bin\", program, size); */\n" +
            "    kprint(\"[IO] Exported to program.bin\\n\");\n" +
            "}\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* IDE MAIN LOOP                                                */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "void start_ide() {\n" +
            "    init_vga();\n" +
            "    init_mouse();\n" +
            "    \n" +
            "    kprint(\"[FrayASM] Visual Assembly Workshop started\\n\");\n" +
            "    \n" +
            "    /* Create demo program: MOV EAX, 10 â†’ ADD EAX, 5 â†’ RET */\n" +
            "    program_head = alloc_block();\n" +
            "    program_head->x = 100; program_head->y = 50;\n" +
            "    program_head->w = 50; program_head->h = 30;\n" +
            "    program_head->type = BLOCK_MOV;\n" +
            "    program_head->reg = 0;  /* EAX */\n" +
            "    program_head->val = 10;\n" +
            "    \n" +
            "    program_head->next = alloc_block();\n" +
            "    program_head->next->x = 170; program_head->next->y = 50;\n" +
            "    program_head->next->w = 50; program_head->next->h = 30;\n" +
            "    program_head->next->type = BLOCK_ADD;\n" +
            "    program_head->next->reg = 0;\n" +
            "    program_head->next->val = 5;\n" +
            "    \n" +
            "    program_head->next->next = alloc_block();\n" +
            "    program_head->next->next->x = 240; program_head->next->next->y = 50;\n" +
            "    program_head->next->next->w = 50; program_head->next->next->h = 30;\n" +
            "    program_head->next->next->type = BLOCK_RET;\n" +
            "    program_head->next->next->next = 0;\n" +
            "    \n" +
            "    int last_buttons = 0;\n" +
            "    \n" +
            "    while(1) {\n" +
            "        draw_ide();\n" +
            "        handle_mouse_interrupt();\n" +
            "        draw_cursor();\n" +
            "        \n" +
            "        /* Handle BUILD button click */\n" +
            "        if((mouse_buttons & 1) && !(last_buttons & 1)) {\n" +
            "            if(point_in_rect(mouse_x, mouse_y, 240, 183, 75, 14)) {\n" +
            "                export_program();\n" +
            "            }\n" +
            "        }\n" +
            "        last_buttons = mouse_buttons;\n" +
            "        \n" +
            "        /* Frame delay */\n" +
            "        for(volatile int i = 0; i < 50000; i++);\n" +
            "    }\n" +
            "}\n";

        writeFile(OUTPUT_DIR + "/ide.c", cCode);
        System.out.println("   ğŸ“„ GENERATED: " + OUTPUT_DIR + "/ide.c");
    }
    
    /**
     * Write file with proper directory creation.
     */
    private static void writeFile(String path, String content) throws IOException {
        File file = new File(path);
        file.getParentFile().mkdirs();
        
        try (FileWriter fw = new FileWriter(file)) {
            fw.write(content);
        }
    }
    
    /**
     * Get IDE statistics.
     */
    public static String getStats() {
        StringBuilder sb = new StringBuilder();
        sb.append("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
        sb.append("â•‘  ğŸ› ï¸ FRAYASM - VISUAL ASSEMBLY WORKSHOP                     â•‘\n");
        sb.append("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
        sb.append("\"Visual Assembly. The power of God in a children's toy.\"\n\n");
        sb.append("Concept: Drag-and-drop x86 assembly programming\n\n");
        sb.append("Instruction Blocks:\n");
        sb.append("  ğŸ”µ MOV - Move immediate to register (B8 opcode)\n");
        sb.append("  ğŸŸ¢ ADD - Add immediate to register (05 opcode)\n");
        sb.append("  ğŸŸ¡ SUB - Subtract immediate (2D opcode)\n");
        sb.append("  ğŸ”´ INT - Software interrupt (CD opcode)\n");
        sb.append("  âšª RET - Return from function (C3 opcode)\n\n");
        sb.append("Workflow:\n");
        sb.append("  1. Drag blocks from toolbox to workspace\n");
        sb.append("  2. Connect blocks in execution order\n");
        sb.append("  3. Set register and immediate values\n");
        sb.append("  4. Click BUILD to compile\n");
        sb.append("  5. Export as binary or hex dump\n\n");
        sb.append("Output Formats:\n");
        sb.append("  - program.bin (binary file in FrayFS)\n");
        sb.append("  - Hex dump (copy-paste to external tools)\n\n");
        sb.append("Example Program:\n");
        sb.append("  MOV EAX, 10  â†’  B8 0A 00 00 00\n");
        sb.append("  ADD EAX, 5   â†’  05 05 00 00 00\n");
        sb.append("  RET          â†’  C3\n\n");
        sb.append("Ï†^75 Validation Seal: 4721424167835376.00\n");
        
        return sb.toString();
    }
}
