/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* FRAY-ABSORBER: DYNAMIC LIBRARY LOADER                       */
/* I know Kung Fu.                                             */
/* Generated by Fraymus Agent Brain v3.0                       */
/* Ï†^75 Validation Seal: 4721424167835376.00                  */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* DYNAMIC LINKING STRUCTURES                                   */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#define MAX_LIBRARIES 32
#define MAX_SYMBOLS 256

/* Loaded library handle */
typedef struct {
    char name[64];
    void* handle;           /* dlopen handle */
    int symbol_count;
    char symbols[MAX_SYMBOLS][64];
    void* addresses[MAX_SYMBOLS];
    int active;
} Library;

Library loaded_libraries[MAX_LIBRARIES];
int library_count = 0;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* DYNAMIC LOADING (dlopen/LoadLibrary)                        */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Platform-specific dynamic loading */
#ifdef __linux__
#include <dlfcn.h>
#define LOAD_LIBRARY(path) dlopen(path, RTLD_LAZY)
#define GET_SYMBOL(handle, name) dlsym(handle, name)
#define CLOSE_LIBRARY(handle) dlclose(handle)
#elif _WIN32
#include <windows.h>
#define LOAD_LIBRARY(path) LoadLibrary(path)
#define GET_SYMBOL(handle, name) GetProcAddress(handle, name)
#define CLOSE_LIBRARY(handle) FreeLibrary(handle)
#else
/* Bare metal: No dynamic loading (compile-time only) */
#define LOAD_LIBRARY(path) 0
#define GET_SYMBOL(handle, name) 0
#define CLOSE_LIBRARY(handle)
#endif

/* Load library from disk */
int absorb_library(const char* path) {
    if(library_count >= MAX_LIBRARIES) {
        kprint("âŒ [ABSORBER] Library limit reached\n");
        return 0;
    }
    
    kprint("âš¡ [ABSORBER] Loading: ");
    kprint(path);
    kprint("\n");
    
    /* Load library */
    void* handle = LOAD_LIBRARY(path);
    
    if(!handle) {
        kprint("âŒ [ABSORBER] Failed to load library\n");
        return 0;
    }
    
    /* Store in registry */
    Library* lib = &loaded_libraries[library_count];
    lib->handle = handle;
    lib->symbol_count = 0;
    lib->active = 1;
    
    /* Copy library name */
    int i = 0;
    while(path[i] != '\0' && i < 63) {
        lib->name[i] = path[i];
        i++;
    }
    lib->name[i] = '\0';
    
    library_count++;
    
    kprint("âœ… [ABSORBER] Library loaded successfully\n");
    
    /* Scan for capabilities */
    scan_library_capabilities(lib);
    
    return 1;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* CAPABILITY DETECTION                                         */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Common symbol names to look for */
const char* common_symbols[] = {
    "main",
    "init",
    "setup",
    "draw",
    "update",
    "render",
    "create_window",
    "init_graphics",
    "process",
    0  /* Null terminator */
};

/* Scan library for known capabilities */
void scan_library_capabilities(Library* lib) {
    kprint("ğŸ” [ABSORBER] Scanning capabilities...\n");
    
    /* Try to find common symbols */
    for(int i = 0; common_symbols[i] != 0; i++) {
        void* addr = GET_SYMBOL(lib->handle, common_symbols[i]);
        
        if(addr) {
            kprint("   âœ… Found: ");
            kprint(common_symbols[i]);
            kprint("\n");
            
            /* Store symbol */
            if(lib->symbol_count < MAX_SYMBOLS) {
                int j = 0;
                while(common_symbols[i][j] != '\0' && j < 63) {
                    lib->symbols[lib->symbol_count][j] = common_symbols[i][j];
                    j++;
                }
                lib->symbols[lib->symbol_count][j] = '\0';
                lib->addresses[lib->symbol_count] = addr;
                lib->symbol_count++;
            }
        }
    }
    
    kprint("ğŸ” [ABSORBER] Found ");
    print_int(lib->symbol_count);
    kprint(" capabilities\n");
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* SYMBOL RESOLUTION                                            */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Find symbol across all loaded libraries */
void* resolve_symbol(const char* symbol_name) {
    for(int i = 0; i < library_count; i++) {
        Library* lib = &loaded_libraries[i];
        
        if(!lib->active) continue;
        
        /* Search symbol table */
        for(int j = 0; j < lib->symbol_count; j++) {
            /* Compare strings */
            int match = 1;
            for(int k = 0; k < 64; k++) {
                if(lib->symbols[j][k] != symbol_name[k]) {
                    match = 0;
                    break;
                }
                if(symbol_name[k] == '\0') break;
            }
            
            if(match) {
                return lib->addresses[j];
            }
        }
    }
    
    return 0;  /* Symbol not found */
}

/* Execute function by name */
void execute_symbol(const char* symbol_name) {
    void* addr = resolve_symbol(symbol_name);
    
    if(addr) {
        kprint("âš¡ [ABSORBER] Executing: ");
        kprint(symbol_name);
        kprint("\n");
        
        /* Call function (no args for now) */
        void (*func)(void) = (void (*)(void))addr;
        func();
    } else {
        kprint("âŒ [ABSORBER] Symbol not found: ");
        kprint(symbol_name);
        kprint("\n");
    }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* LIBRARY MANAGEMENT                                           */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* List all loaded libraries */
void list_libraries() {
    kprint("ğŸ“š [ABSORBER] Loaded Libraries:\n");
    
    for(int i = 0; i < library_count; i++) {
        if(loaded_libraries[i].active) {
            kprint("   ");
            print_int(i);
            kprint(". ");
            kprint(loaded_libraries[i].name);
            kprint(" (");
            print_int(loaded_libraries[i].symbol_count);
            kprint(" symbols)\n");
        }
    }
}

/* Unload library */
void unload_library(int index) {
    if(index < 0 || index >= library_count) return;
    
    Library* lib = &loaded_libraries[index];
    
    if(lib->active) {
        kprint("ğŸ—‘ï¸ [ABSORBER] Unloading: ");
        kprint(lib->name);
        kprint("\n");
        
        CLOSE_LIBRARY(lib->handle);
        lib->active = 0;
    }
}

/* Initialize absorber system */
void init_absorber() {
    kprint("[ABSORBER] Dynamic library loader initialized\n");
    kprint("[ABSORBER] Ready to assimilate external capabilities\n");
    
    library_count = 0;
}
