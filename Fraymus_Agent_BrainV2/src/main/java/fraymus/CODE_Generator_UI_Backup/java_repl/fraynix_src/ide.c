/* ═══════════════════════════════════════════════════════════ */
/* FRAY-ASM: VISUAL ASSEMBLY IDE                               */
/* Blocks convert directly to x86 OpCodes                      */
/* Generated by Fraymus Agent Brain v3.0                       */
/* φ^75 Validation Seal: 4721424167835376.00                  */
/* ═══════════════════════════════════════════════════════════ */

/* ═══════════════════════════════════════════════════════════ */
/* INSTRUCTION BLOCK STRUCTURE                                  */
/* ═══════════════════════════════════════════════════════════ */

/* Block types */
#define BLOCK_MOV  0
#define BLOCK_ADD  1
#define BLOCK_SUB  2
#define BLOCK_INT  3
#define BLOCK_RET  4
#define BLOCK_JMP  5
#define BLOCK_CMP  6

/* Visual block */
struct Block {
    int x, y;              /* Screen position */
    int w, h;              /* Dimensions */
    int type;              /* Instruction type */
    int reg;               /* Register (0=EAX, 1=EBX, 2=ECX, 3=EDX) */
    int val;               /* Immediate value */
    struct Block* next;    /* Next in chain */
};

/* Program chain */
struct Block* program_head = 0;
struct Block* selected_block = 0;

/* ═══════════════════════════════════════════════════════════ */
/* MEMORY ALLOCATOR (Simplified)                               */
/* ═══════════════════════════════════════════════════════════ */

unsigned char block_memory[4096];  /* 4KB for blocks */
int block_memory_offset = 0;

struct Block* alloc_block() {
    if(block_memory_offset + sizeof(struct Block) > 4096) {
        return 0;  /* Out of memory */
    }
    struct Block* b = (struct Block*)(block_memory + block_memory_offset);
    block_memory_offset += sizeof(struct Block);
    return b;
}

/* ═══════════════════════════════════════════════════════════ */
/* VISUAL RENDERING                                             */
/* ═══════════════════════════════════════════════════════════ */

/* Draw instruction block */
void draw_block(struct Block* b) {
    unsigned char color;
    
    /* Color by type */
    switch(b->type) {
        case BLOCK_MOV: color = 1; break;   /* Blue */
        case BLOCK_ADD: color = 2; break;   /* Green */
        case BLOCK_SUB: color = 6; break;   /* Brown */
        case BLOCK_INT: color = 4; break;   /* Red */
        case BLOCK_RET: color = 15; break;  /* White */
        default: color = 8; break;          /* Gray */
    }
    
    /* Draw block body */
    draw_rect(b->x, b->y, b->w, b->h, color);
    
    /* Draw border (lighter) */
    draw_hline(b->x, b->x + b->w - 1, b->y, 15);
    draw_vline(b->x, b->y, b->y + b->h - 1, 15);
    
    /* Highlight if selected */
    if(b == selected_block) {
        draw_rect(b->x - 2, b->y - 2, b->w + 4, b->h + 4, 14);  /* Gold outline */
    }
}

/* Draw toolbox icon */
void draw_toolbox_icon(int x, int y, const char* label, unsigned char color) {
    draw_rect(x, y, 60, 20, color);
    draw_hline(x, x + 59, y, 15);
    draw_vline(x, y, y + 19, 15);
    /* Would render label text here */
}

/* Draw connection line between blocks */
void draw_connection(struct Block* from, struct Block* to) {
    int x1 = from->x + from->w;
    int y1 = from->y + from->h / 2;
    int x2 = to->x;
    int y2 = to->y + to->h / 2;
    
    draw_line(x1, y1, x2, y2, 15);  /* White connection */
}

/* ═══════════════════════════════════════════════════════════ */
/* IDE MAIN RENDERER                                            */
/* ═══════════════════════════════════════════════════════════ */

void draw_ide() {
    /* 1. BACKGROUND */
    draw_rect(0, 0, 320, 200, 0);  /* Black workspace */
    
    /* 2. TOOLBOX SIDEBAR */
    draw_rect(0, 0, 70, 200, 8);  /* Dark gray */
    
    /* Toolbox title */
    draw_rect(0, 0, 70, 15, 14);  /* Gold header */
    
    /* Instruction blocks */
    draw_toolbox_icon(5, 20, "MOV", 1);   /* Blue */
    draw_toolbox_icon(5, 45, "ADD", 2);   /* Green */
    draw_toolbox_icon(5, 70, "SUB", 6);   /* Brown */
    draw_toolbox_icon(5, 95, "INT", 4);   /* Red */
    draw_toolbox_icon(5, 120, "RET", 15); /* White */
    
    /* 3. WORKSPACE GRID (optional) */
    for(int x = 80; x < 320; x += 20) {
        draw_vline(x, 0, 180, 24);  /* Very dark gray grid */
    }
    for(int y = 0; y < 180; y += 20) {
        draw_hline(80, 319, y, 24);
    }
    
    /* 4. DRAW PROGRAM CHAIN */
    struct Block* curr = program_head;
    while(curr != 0) {
        draw_block(curr);
        
        /* Draw connection to next */
        if(curr->next != 0) {
            draw_connection(curr, curr->next);
        }
        
        curr = curr->next;
    }
    
    /* 5. BOTTOM TOOLBAR */
    draw_rect(0, 180, 320, 20, 8);  /* Dark gray */
    
    /* BUILD button */
    draw_rect(240, 183, 75, 14, 14);  /* Gold */
    /* Label: "BUILD" */
    
    /* Status text area */
    /* Would show "Ready" or "Compiled" here */
}

/* ═══════════════════════════════════════════════════════════ */
/* x86 COMPILER (Blocks → Machine Code)                        */
/* ═══════════════════════════════════════════════════════════ */

/* Compile program chain to machine code */
int compile_program(unsigned char* output) {
    int idx = 0;
    struct Block* curr = program_head;
    
    kprint("[ASM] Compiling program...\n");
    
    while(curr != 0) {
        switch(curr->type) {
            case BLOCK_MOV:
                /* MOV EAX, imm32 = B8 [imm32] */
                if(curr->reg == 0) {  /* EAX */
                    output[idx++] = 0xB8;
                    output[idx++] = (curr->val & 0xFF);
                    output[idx++] = ((curr->val >> 8) & 0xFF);
                    output[idx++] = ((curr->val >> 16) & 0xFF);
                    output[idx++] = ((curr->val >> 24) & 0xFF);
                }
                /* Other registers: BB (EBX), B9 (ECX), BA (EDX) */
                break;
                
            case BLOCK_ADD:
                /* ADD EAX, imm32 = 05 [imm32] */
                if(curr->reg == 0) {
                    output[idx++] = 0x05;
                    output[idx++] = (curr->val & 0xFF);
                    output[idx++] = ((curr->val >> 8) & 0xFF);
                    output[idx++] = ((curr->val >> 16) & 0xFF);
                    output[idx++] = ((curr->val >> 24) & 0xFF);
                }
                break;
                
            case BLOCK_SUB:
                /* SUB EAX, imm32 = 2D [imm32] */
                if(curr->reg == 0) {
                    output[idx++] = 0x2D;
                    output[idx++] = (curr->val & 0xFF);
                    output[idx++] = ((curr->val >> 8) & 0xFF);
                    output[idx++] = ((curr->val >> 16) & 0xFF);
                    output[idx++] = ((curr->val >> 24) & 0xFF);
                }
                break;
                
            case BLOCK_INT:
                /* INT imm8 = CD [imm8] */
                output[idx++] = 0xCD;
                output[idx++] = (curr->val & 0xFF);
                break;
                
            case BLOCK_RET:
                /* RET = C3 */
                output[idx++] = 0xC3;
                break;
        }
        
        curr = curr->next;
    }
    
    kprint("[ASM] Compilation complete. Size: ");
    char buf[16];
    int_to_str(idx, buf);
    kprint(buf);
    kprint(" bytes\n");
    
    return idx;
}

/* Export compiled program */
void export_program() {
    unsigned char program[1024];
    int size = compile_program(program);
    
    /* Print hex dump for copy-paste */
    kprint("\n[EXPORT] HEX DUMP:\n");
    for(int i = 0; i < size; i++) {
        char hex[4];
        /* Convert byte to hex string */
        unsigned char b = program[i];
        hex[0] = (b >> 4) < 10 ? '0' + (b >> 4) : 'A' + (b >> 4) - 10;
        hex[1] = (b & 0xF) < 10 ? '0' + (b & 0xF) : 'A' + (b & 0xF) - 10;
        hex[2] = ' ';
        hex[3] = '\0';
        kprint(hex);
    }
    kprint("\n");
    
    /* Write to FrayFS */
    /* write_file("program.bin", program, size); */
    kprint("[IO] Exported to program.bin\n");
}

/* ═══════════════════════════════════════════════════════════ */
/* IDE MAIN LOOP                                                */
/* ═══════════════════════════════════════════════════════════ */

void start_ide() {
    init_vga();
    init_mouse();
    
    kprint("[FrayASM] Visual Assembly Workshop started\n");
    
    /* Create demo program: MOV EAX, 10 → ADD EAX, 5 → RET */
    program_head = alloc_block();
    program_head->x = 100; program_head->y = 50;
    program_head->w = 50; program_head->h = 30;
    program_head->type = BLOCK_MOV;
    program_head->reg = 0;  /* EAX */
    program_head->val = 10;
    
    program_head->next = alloc_block();
    program_head->next->x = 170; program_head->next->y = 50;
    program_head->next->w = 50; program_head->next->h = 30;
    program_head->next->type = BLOCK_ADD;
    program_head->next->reg = 0;
    program_head->next->val = 5;
    
    program_head->next->next = alloc_block();
    program_head->next->next->x = 240; program_head->next->next->y = 50;
    program_head->next->next->w = 50; program_head->next->next->h = 30;
    program_head->next->next->type = BLOCK_RET;
    program_head->next->next->next = 0;
    
    int last_buttons = 0;
    
    while(1) {
        draw_ide();
        handle_mouse_interrupt();
        draw_cursor();
        
        /* Handle BUILD button click */
        if((mouse_buttons & 1) && !(last_buttons & 1)) {
            if(point_in_rect(mouse_x, mouse_y, 240, 183, 75, 14)) {
                export_program();
            }
        }
        last_buttons = mouse_buttons;
        
        /* Frame delay */
        for(volatile int i = 0; i < 50000; i++);
    }
}
