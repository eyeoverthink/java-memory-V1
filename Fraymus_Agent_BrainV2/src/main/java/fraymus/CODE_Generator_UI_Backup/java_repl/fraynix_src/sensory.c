/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* FRAY-SENSORY: INPUT LAYER                                   */
/* The Mouth of the Machine.                                   */
/* Generated by Fraymus Agent Brain v3.0                       */
/* Ï†^75 Validation Seal: 4721424167835376.00                  */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* PROBLEM STRUCTURES                                           */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#define MAX_PROBLEM_ROWS 64
#define MAX_PROBLEM_INPUTS 8

/* Training problem */
typedef struct {
    int row_count;
    int input_count;
    int truth_table[MAX_PROBLEM_ROWS][MAX_PROBLEM_INPUTS + 1];
    char name[32];
} Problem;

Problem current_problem;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* FILE PARSING                                                 */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Parse single character as boolean */
int parse_bool(char c) {
    return (c == '1' || c == 't' || c == 'T');
}

/* Parse line: "0,1|1" -> [0, 1, 1] */
int parse_problem_line(const char* line, int* row) {
    int index = 0;
    int col = 0;
    
    /* Skip whitespace */
    while(line[index] == ' ' || line[index] == '\t') index++;
    
    /* Skip comments */
    if(line[index] == '#' || line[index] == '\0') {
        return 0;  /* Empty line */
    }
    
    /* Parse inputs (before |) */
    while(line[index] != '|' && line[index] != '\0') {
        if(line[index] == '0' || line[index] == '1') {
            row[col++] = parse_bool(line[index]);
        }
        index++;
    }
    
    if(line[index] != '|') return 0;  /* Invalid format */
    index++;  /* Skip | */
    
    /* Parse output (after |) */
    while(line[index] == ' ' || line[index] == '\t') index++;
    row[col++] = parse_bool(line[index]);
    
    return col;  /* Return number of columns */
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* PROBLEM INGESTION                                            */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Load problem from FrayFS file */
int ingest_problem(const char* filename) {
    kprint("ğŸ‘„ [SENSORY] Ingesting problem: ");
    kprint(filename);
    kprint("\n");
    
    /* Reset current problem */
    current_problem.row_count = 0;
    current_problem.input_count = 0;
    
    /* Copy filename to problem name */
    int i = 0;
    while(filename[i] != '\0' && i < 31) {
        current_problem.name[i] = filename[i];
        i++;
    }
    current_problem.name[i] = '\0';
    
    /* Read file from FrayFS */
    /* In real implementation: */
    /* 1. Open file in FrayFS */
    /* 2. Read line by line */
    /* 3. Parse each line */
    /* 4. Build truth table */
    
    /* For demo: Load XOR problem hardcoded */
    current_problem.row_count = 4;
    current_problem.input_count = 2;
    
    /* XOR truth table */
    current_problem.truth_table[0][0] = 0;
    current_problem.truth_table[0][1] = 0;
    current_problem.truth_table[0][2] = 0;
    
    current_problem.truth_table[1][0] = 0;
    current_problem.truth_table[1][1] = 1;
    current_problem.truth_table[1][2] = 1;
    
    current_problem.truth_table[2][0] = 1;
    current_problem.truth_table[2][1] = 0;
    current_problem.truth_table[2][2] = 1;
    
    current_problem.truth_table[3][0] = 1;
    current_problem.truth_table[3][1] = 1;
    current_problem.truth_table[3][2] = 0;
    
    kprint("âš¡ [SENSORY] Digested ");
    print_int(current_problem.row_count);
    kprint(" logic rows\n");
    
    return 1;  /* Success */
}

/* Get current problem truth table */
void get_current_truth_table(int dest[][3], int* row_count) {
    *row_count = current_problem.row_count;
    
    for(int i = 0; i < current_problem.row_count; i++) {
        for(int j = 0; j <= current_problem.input_count; j++) {
            dest[i][j] = current_problem.truth_table[i][j];
        }
    }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* INTEGRATION WITH EVOLUTION                                   */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Learn from file */
void learn_from_file(const char* filename) {
    kprint("ğŸ“ [LEARNING] Starting learning session...\n");
    
    /* 1. Ingest problem */
    if(!ingest_problem(filename)) {
        kprint("âŒ [SENSORY] Failed to load problem\n");
        return;
    }
    
    /* 2. Copy to global truth table */
    get_current_truth_table(truth_table, &truth_table_size);
    
    /* 3. Run evolution with memory */
    run_evolution_with_memory(1000, current_problem.name);
    
    kprint("ğŸ“ [LEARNING] Session complete\n");
}

/* Initialize sensory system */
void init_sensory() {
    kprint("[SENSORY] Input layer initialized\n");
    kprint("[SENSORY] Ready to ingest training data\n");
}
