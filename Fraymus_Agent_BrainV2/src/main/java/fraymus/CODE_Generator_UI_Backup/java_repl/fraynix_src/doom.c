/* ═══════════════════════════════════════════════════════════ */
/* FRAY-DOOM: BARE METAL RAYCASTER                             */
/* Wolfenstein 3D / Doom Style Engine                          */
/* Generated by Fraymus Agent Brain v3.0                       */
/* φ^75 Validation Seal: 4721424167835376.00                  */
/* ═══════════════════════════════════════════════════════════ */

/* ═══════════════════════════════════════════════════════════ */
/* WORLD MAP                                                    */
/* ═══════════════════════════════════════════════════════════ */

/* 8x8 Grid: 1 = Wall, 0 = Empty */
int worldMap[8][8] = {
  {1,1,1,1,1,1,1,1},
  {1,0,0,0,0,0,0,1},
  {1,0,0,0,0,1,0,1},
  {1,0,0,0,0,0,0,1},
  {1,0,1,0,1,0,0,1},
  {1,0,1,0,1,0,0,1},
  {1,0,0,0,0,0,0,1},
  {1,1,1,1,1,1,1,1}
};

/* ═══════════════════════════════════════════════════════════ */
/* PLAYER STATE                                                 */
/* ═══════════════════════════════════════════════════════════ */

/* Position (floating point simulation with fixed point) */
int posX_fixed = 3500;  /* 3.5 * 1000 */
int posY_fixed = 3500;  /* 3.5 * 1000 */

/* Direction vector */
int dirX_fixed = -1000; /* -1.0 * 1000 */
int dirY_fixed = 0;

/* Camera plane (perpendicular to direction) */
int planeX_fixed = 0;
int planeY_fixed = 660;  /* 0.66 * 1000 */

/* ═══════════════════════════════════════════════════════════ */
/* RAYCASTING (DDA Algorithm)                                   */
/* ═══════════════════════════════════════════════════════════ */

/* Cast ray and return wall distance */
int cast_ray(int screen_x, int *hit_side) {
    /* Calculate ray direction */
    int cameraX = (2 * screen_x * 1000) / 320 - 1000;
    int rayDirX = dirX_fixed + (planeX_fixed * cameraX) / 1000;
    int rayDirY = dirY_fixed + (planeY_fixed * cameraX) / 1000;
    
    /* Current map position */
    int mapX = posX_fixed / 1000;
    int mapY = posY_fixed / 1000;
    
    /* DDA variables */
    int stepX, stepY;
    int sideDistX, sideDistY;
    
    /* Calculate step direction and initial sideDist */
    int deltaDistX = (rayDirX == 0) ? 99999 : (1000000 / rayDirX);
    int deltaDistY = (rayDirY == 0) ? 99999 : (1000000 / rayDirY);
    if(deltaDistX < 0) deltaDistX = -deltaDistX;
    if(deltaDistY < 0) deltaDistY = -deltaDistY;
    
    if(rayDirX < 0) {
        stepX = -1;
        sideDistX = ((posX_fixed % 1000) * deltaDistX) / 1000;
    } else {
        stepX = 1;
        sideDistX = ((1000 - (posX_fixed % 1000)) * deltaDistX) / 1000;
    }
    
    if(rayDirY < 0) {
        stepY = -1;
        sideDistY = ((posY_fixed % 1000) * deltaDistY) / 1000;
    } else {
        stepY = 1;
        sideDistY = ((1000 - (posY_fixed % 1000)) * deltaDistY) / 1000;
    }
    
    /* DDA loop */
    int hit = 0;
    int side = 0;
    
    while(hit == 0 && mapX >= 0 && mapX < 8 && mapY >= 0 && mapY < 8) {
        /* Jump to next square */
        if(sideDistX < sideDistY) {
            sideDistX += deltaDistX;
            mapX += stepX;
            side = 0;
        } else {
            sideDistY += deltaDistY;
            mapY += stepY;
            side = 1;
        }
        
        /* Check if ray hit wall */
        if(mapX >= 0 && mapX < 8 && mapY >= 0 && mapY < 8) {
            if(worldMap[mapX][mapY] > 0) hit = 1;
        } else {
            hit = 1;  /* Hit boundary */
        }
    }
    
    /* Calculate perpendicular wall distance */
    int perpWallDist;
    if(side == 0) {
        perpWallDist = ((mapX * 1000 - posX_fixed + ((1 - stepX) * 500)) * 1000) / rayDirX;
    } else {
        perpWallDist = ((mapY * 1000 - posY_fixed + ((1 - stepY) * 500)) * 1000) / rayDirY;
    }
    if(perpWallDist < 0) perpWallDist = -perpWallDist;
    
    *hit_side = side;
    return perpWallDist;
}

/* ═══════════════════════════════════════════════════════════ */
/* GAME LOOP                                                    */
/* ═══════════════════════════════════════════════════════════ */

void doom_loop() {
    /* Initialize graphics */
    init_vga();
    init_network();
    
    kprint("[DOOM] Game started. Use WASD to move.\n");
    
    int frame = 0;
    
    while(1) {
        /* 1. RENDER FRAME */
        
        /* Draw ceiling (gray) */
        draw_rect(0, 0, 320, 100, 8);
        
        /* Draw floor (brown) */
        draw_rect(0, 100, 320, 100, 6);
        
        /* Raycast every vertical stripe */
        for(int x = 0; x < 320; x++) {
            int hit_side;
            int perpWallDist = cast_ray(x, &hit_side);
            
            /* Calculate wall height */
            int lineHeight = (200 * 1000) / (perpWallDist + 1);
            
            /* Calculate draw start/end */
            int drawStart = -lineHeight / 2 + 100;
            if(drawStart < 0) drawStart = 0;
            int drawEnd = lineHeight / 2 + 100;
            if(drawEnd >= 200) drawEnd = 199;
            
            /* Choose wall color */
            unsigned char color = 4;  /* Red */
            if(hit_side == 1) color = 12;  /* Lighter red for Y-side */
            
            /* Draw vertical line */
            draw_vline(x, drawStart, drawEnd, color);
        }
        
        /* 2. BROADCAST POSITION (every 10 frames) */
        if(frame % 10 == 0) {
            net_broadcast_position(posX_fixed / 1000, posY_fixed / 1000, 0);
        }
        
        /* 3. HANDLE INPUT */
        /* Note: Would need non-blocking keyboard input */
        /* For now: Simplified movement */
        
        /* W - Move forward */
        /* S - Move backward */
        /* A - Turn left */
        /* D - Turn right */
        
        frame++;
        
        /* Small delay to control frame rate */
        for(volatile int i = 0; i < 100000; i++);
    }
}

/* Movement functions */
void move_forward() {
    int newX = posX_fixed + (dirX_fixed * 100) / 1000;
    int newY = posY_fixed + (dirY_fixed * 100) / 1000;
    
    /* Collision detection */
    if(worldMap[newX / 1000][newY / 1000] == 0) {
        posX_fixed = newX;
        posY_fixed = newY;
    }
}

void move_backward() {
    int newX = posX_fixed - (dirX_fixed * 100) / 1000;
    int newY = posY_fixed - (dirY_fixed * 100) / 1000;
    
    if(worldMap[newX / 1000][newY / 1000] == 0) {
        posX_fixed = newX;
        posY_fixed = newY;
    }
}

void turn_left() {
    /* Rotate direction and plane vectors */
    int oldDirX = dirX_fixed;
    dirX_fixed = (dirX_fixed * 995 - dirY_fixed * 100) / 1000;
    dirY_fixed = (oldDirX * 100 + dirY_fixed * 995) / 1000;
    
    int oldPlaneX = planeX_fixed;
    planeX_fixed = (planeX_fixed * 995 - planeY_fixed * 100) / 1000;
    planeY_fixed = (oldPlaneX * 100 + planeY_fixed * 995) / 1000;
}

void turn_right() {
    /* Rotate direction and plane vectors */
    int oldDirX = dirX_fixed;
    dirX_fixed = (dirX_fixed * 995 + dirY_fixed * 100) / 1000;
    dirY_fixed = (-oldDirX * 100 + dirY_fixed * 995) / 1000;
    
    int oldPlaneX = planeX_fixed;
    planeX_fixed = (planeX_fixed * 995 + planeY_fixed * 100) / 1000;
    planeY_fixed = (-oldPlaneX * 100 + planeY_fixed * 995) / 1000;
}
