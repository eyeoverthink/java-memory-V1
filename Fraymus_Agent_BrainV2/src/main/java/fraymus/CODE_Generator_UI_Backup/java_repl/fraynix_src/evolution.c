/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* FRAY-EVOLUTION: EVOLUTIONARY LOOP ENGINE                    */
/* The Body that drives the Brain.                             */
/* Generated by Fraymus Agent Brain v3.0                       */
/* Ï†^75 Validation Seal: 4721424167835376.00                  */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Include circuit evolution */
/* #include "circuit.c" */

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* POPULATION MANAGEMENT                                        */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

#define POPULATION_SIZE 100
#define ELITE_PERCENT 10
#define ELITE_COUNT (POPULATION_SIZE * ELITE_PERCENT / 100)

/* Population of circuits */
typedef struct {
    Gate dna[MAX_GATES];
    int gate_count;
    double fitness;
} Circuit;

Circuit population[POPULATION_SIZE];
Circuit next_generation[POPULATION_SIZE];
int generation = 0;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* CIRCUIT OPERATIONS                                           */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Clone circuit */
void clone_circuit(Circuit* dest, Circuit* src) {
    dest->gate_count = src->gate_count;
    dest->fitness = src->fitness;
    
    for(int i = 0; i < src->gate_count; i++) {
        dest->dna[i] = src->dna[i];
    }
}

/* Mutate circuit with temperature */
void mutate_circuit_temp(Circuit* c, double temperature) {
    /* Higher temperature = more mutation */
    for(int i = 0; i < c->gate_count; i++) {
        if(random_double() < temperature) {
            /* Rewire gate */
            c->dna[i].input_a_index = random() % (c->gate_count + 2);
            c->dna[i].operation = (GateOp)(random() % 5);
        }
    }
    
    /* Add gate if temperature high */
    if(random_double() < temperature && c->gate_count < MAX_GATES) {
        Gate* g = &c->dna[c->gate_count];
        g->operation = (GateOp)(random() % 5);
        g->input_a_index = random() % (c->gate_count + 2);
        g->input_b_index = random() % (c->gate_count + 2);
        g->active = 1;
        c->gate_count++;
    }
}

/* Evaluate circuit fitness */
double evaluate_circuit(Circuit* c) {
    int correct = 0;
    int total = 4;
    
    /* Copy circuit to global state for testing */
    for(int i = 0; i < c->gate_count; i++) {
        circuit_dna[i] = c->dna[i];
    }
    gate_count = c->gate_count;
    
    /* Test against truth table */
    for(int i = 0; i < total; i++) {
        int input_a = truth_table[i][0];
        int input_b = truth_table[i][1];
        int expected = truth_table[i][2];
        
        int output = process_circuit(input_a, input_b);
        
        if(output == expected) {
            correct++;
        }
    }
    
    return (double)correct / (double)total;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* SORTING (Selection Pressure)                                */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Bubble sort by fitness (descending) */
void sort_population_by_fitness() {
    for(int i = 0; i < POPULATION_SIZE - 1; i++) {
        for(int j = 0; j < POPULATION_SIZE - i - 1; j++) {
            if(population[j].fitness < population[j + 1].fitness) {
                /* Swap */
                Circuit temp = population[j];
                population[j] = population[j + 1];
                population[j + 1] = temp;
            }
        }
    }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* EVOLUTIONARY LOOP                                            */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

void run_evolution(int max_generations) {
    kprint("ðŸ”¥ [EVOLUTION] Igniting Lazarus Engine...\n");
    
    /* Initialize population with random circuits */
    for(int i = 0; i < POPULATION_SIZE; i++) {
        population[i].gate_count = 0;
        population[i].fitness = 0.0;
        
        /* Spawn random gates */
        for(int j = 0; j < 10; j++) {
            Gate* g = &population[i].dna[population[i].gate_count];
            g->operation = (GateOp)(random() % 5);
            g->input_a_index = random() % (population[i].gate_count + 2);
            g->input_b_index = random() % (population[i].gate_count + 2);
            g->active = 1;
            population[i].gate_count++;
        }
    }
    
    /* Evolution loop */
    for(generation = 1; generation <= max_generations; generation++) {
        
        /* 1. EVALUATE - Test all circuits */
        for(int i = 0; i < POPULATION_SIZE; i++) {
            population[i].fitness = evaluate_circuit(&population[i]);
        }
        
        /* 2. SELECTION - Sort by fitness */
        sort_population_by_fitness();
        
        /* Get alpha (best) circuit */
        Circuit* alpha = &population[0];
        
        /* Log progress every 100 generations */
        if(generation % 100 == 0) {
            kprint("[GEN ");
            print_int(generation);
            kprint("] Alpha Fitness: ");
            print_float(alpha->fitness * 100.0);
            kprint("%\n");
        }
        
        /* 3. CHECK VICTORY */
        if(alpha->fitness >= 1.0) {
            kprint("âœ¨ [EVOLUTION] SOLUTION EVOLVED in Gen ");
            print_int(generation);
            kprint("\n");
            kprint("   > The Machine derived XOR logic from chaos.\n");
            
            /* Store in Lazarus */
            /* thermal_injection(alpha->dna, alpha->fitness); */
            return;
        }
        
        /* 4. BREEDING - Create next generation */
        int next_index = 0;
        
        /* Elitism: Keep top 10% unchanged */
        for(int i = 0; i < ELITE_COUNT; i++) {
            clone_circuit(&next_generation[next_index], &population[i]);
            next_index++;
        }
        
        /* Fill rest by breeding top 50% */
        while(next_index < POPULATION_SIZE) {
            /* Select parent from top 50% */
            int parent_index = random() % (POPULATION_SIZE / 2);
            Circuit* parent = &population[parent_index];
            
            /* Clone parent */
            clone_circuit(&next_generation[next_index], parent);
            
            /* 5. THERMAL INJECTION - Mutate based on fitness */
            /* Low fitness = high temperature = more mutation */
            double temperature = 1.0 - parent->fitness;
            mutate_circuit_temp(&next_generation[next_index], temperature);
            
            next_index++;
        }
        
        /* Replace population */
        for(int i = 0; i < POPULATION_SIZE; i++) {
            population[i] = next_generation[i];
        }
    }
    
    kprint("[EVOLUTION] Max generations reached. Best fitness: ");
    print_float(population[0].fitness * 100.0);
    kprint("%\n");
}

/* Initialize evolution system */
void init_evolution_engine() {
    kprint("[EVOLUTION] Evolutionary loop initialized\n");
    
    /* Run evolution to solve XOR */
    run_evolution(1000);  /* 1000 generations max */
}
