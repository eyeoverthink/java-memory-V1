/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* FRAY-EXPLORER: VISUAL FILE MANAGER                          */
/* Reads FrayFS headers directly from Memory                   */
/* Generated by Fraymus Agent Brain v3.0                       */
/* Ï†^75 Validation Seal: 4721424167835376.00                  */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* DATA STRUCTURES                                              */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

struct FileEntry {
    char name[32];
    int size;
    char* data_ptr;
    int active; /* 1=Exists, 0=Deleted */
};

struct FileEntry files[64]; /* Cache up to 64 files */
int file_count = 0;
int selected_idx = 0;
char* fs_base = (char*)0x200000; /* Where system.img is loaded */

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* FILESYSTEM PARSER                                            */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Scan disk image and populate file cache */
void scan_disk() {
    file_count = 0;
    char* ptr = fs_base;
    
    while(ptr[0] == 'F' && ptr[1] == 'R' && ptr[2] == 'A' && ptr[3] == 'Y') {
        /* Found FrayFS Header */
        struct FileEntry* f = &files[file_count];
        
        /* Copy Name (32 bytes at offset 4) */
        for(int i=0; i<32; i++) f->name[i] = ptr[4+i];
        
        /* Read Size (Big Endian, 4 bytes at offset 36) */
        unsigned char* size_bytes = (unsigned char*)(ptr + 36);
        f->size = (size_bytes[0]<<24) | (size_bytes[1]<<16) | (size_bytes[2]<<8) | size_bytes[3];
        
        f->data_ptr = ptr + 64; /* Data starts after 64-byte header */
        f->active = 1;
        
        file_count++;
        if(file_count >= 64) break; /* Cache limit */
        
        /* Jump to next file */
        ptr += (64 + f->size);
    }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* STRING UTILITIES                                             */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Check if string ends with suffix */
int str_ends_with(const char* str, const char* suffix) {
    int str_len = 0;
    int suf_len = 0;
    
    while(str[str_len] != '\0') str_len++;
    while(suffix[suf_len] != '\0') suf_len++;
    
    if(suf_len > str_len) return 0;
    
    for(int i=0; i<suf_len; i++) {
        if(str[str_len - suf_len + i] != suffix[i]) return 0;
    }
    
    return 1;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* FILE OPERATIONS                                              */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Delete file (mark as inactive) */
void delete_file(int idx) {
    if(idx < 0 || idx >= file_count) return;
    
    /* Mark as deleted */
    files[idx].active = 0;
    
    kprint("[FS] FILE DELETED: ");
    kprint(files[idx].name);
    kprint("\n");
}

/* Open/Execute file based on type */
void open_file(int idx) {
    if(idx < 0 || idx >= file_count) return;
    if(files[idx].active == 0) return;
    
    struct FileEntry* f = &files[idx];
    
    kprint("[OS] OPENING: ");
    kprint(f->name);
    kprint("\n");
    
    /* Check file extension */
    if (str_ends_with(f->name, ".bin")) {
        /* Execute binary */
        kprint("[OS] EXECUTING BINARY...\n");
        void (*prog)() = (void (*)())f->data_ptr;
        prog();
    }
    else if (str_ends_with(f->name, ".txt")) {
        /* Display text file */
        kprint("[OS] OPENING DOCUMENT...\n");
        kprint("--- BEGIN FILE ---\n");
        
        /* Print file contents */
        for(int i=0; i<f->size && i<1024; i++) {
            char c = f->data_ptr[i];
            if(c == '\0') break;
            /* Print character */
            char buf[2] = {c, '\0'};
            kprint(buf);
        }
        
        kprint("\n--- END FILE ---\n");
        kprint("Press any key to continue...\n");
        get_char();
    }
    else {
        kprint("[OS] UNKNOWN FILE TYPE\n");
    }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* UI RENDERER                                                  */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Draw file explorer window */
void draw_explorer() {
    /* Clear screen */
    clear_screen();
    
    /* Title */
    kprint("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    kprint("â•‘  ğŸ“‚ FRAY FILES EXPLORER                                    â•‘\n");
    kprint("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    /* File list */
    int active_count = 0;
    for(int i=0; i<file_count; i++) {
        if(files[i].active == 0) continue;
        
        /* Selection indicator */
        if(i == selected_idx) {
            kprint("  â–º "); /* Selection arrow */
        } else {
            kprint("    ");
        }
        
        /* Icon based on file type */
        if (str_ends_with(files[i].name, ".txt")) {
            kprint("ğŸ“„ "); /* Document icon */
        }
        else if (str_ends_with(files[i].name, ".bin")) {
            kprint("âš™ï¸  "); /* Executable icon */
        }
        else {
            kprint("ğŸ“¦ "); /* Generic file icon */
        }
        
        /* File name */
        kprint(files[i].name);
        
        /* File size */
        kprint(" (");
        print_int(files[i].size);
        kprint(" bytes)\n");
        
        active_count++;
    }
    
    if(active_count == 0) {
        kprint("  (No files found)\n");
    }
    
    /* Status bar */
    kprint("\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    kprint("[W/S] Navigate  [ENTER] Open  [D] Delete  [ESC] Exit\n");
    kprint("Files: ");
    print_int(active_count);
    kprint("/");
    print_int(file_count);
    kprint("\n");
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* MAIN LOOP                                                    */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Start file explorer */
void start_explorer() {
    kprint("[OS] Starting File Explorer...\n");
    
    /* Scan filesystem */
    scan_disk();
    
    kprint("[FS] Found ");
    print_int(file_count);
    kprint(" files\n\n");
    
    /* Main loop */
    while(1) {
        draw_explorer();
        
        /* Get keyboard input */
        char key = get_char();
        
        /* Navigation */
        if (key == 'w' || key == 'W') {
            selected_idx--;
        }
        else if (key == 's' || key == 'S') {
            selected_idx++;
        }
        /* Actions */
        else if (key == '\n' || key == '\r') {
            open_file(selected_idx);
        }
        else if (key == 'd' || key == 'D') {
            delete_file(selected_idx);
        }
        /* Exit */
        else if (key == 0x1B) { /* ESC key */
            kprint("[OS] Exiting File Explorer\n");
            return;
        }
        
        /* Bounds checking */
        if (selected_idx < 0) selected_idx = 0;
        if (selected_idx >= file_count) selected_idx = file_count - 1;
        
        /* Skip deleted files */
        while(selected_idx < file_count && files[selected_idx].active == 0) {
            selected_idx++;
        }
        if(selected_idx >= file_count) {
            /* Wrap around to first active file */
            selected_idx = 0;
            while(selected_idx < file_count && files[selected_idx].active == 0) {
                selected_idx++;
            }
        }
    }
}
