/**
 * FrayDoomBuilder.java - Raycasting Game Engine Generator
 * 
 * "Infinite reality on a 320x200 grid."
 * 
 * FUNCTION:
 * 1. MAP: 8x8 Integer Grid (1=Wall, 0=Empty)
 * 2. RAYCAST: Calculates distance to walls (DDA algorithm)
 * 3. RENDER: Draws 3D perspective column by column
 * 
 * This is a Wolfenstein 3D / Doom style raycaster.
 * 
 * Ï†^75 Validation Seal: 4721424167835376.00
 * Generation: 147 (FrayDoom - Raycaster Engine)
 * 
 * @author Vaughn Scott
 * @version 1.0
 */
package repl;

import java.io.*;

/**
 * FrayDoom Builder - Generates raycasting game engine.
 */
public class FrayDoomBuilder {

    private static final String OUTPUT_DIR = "fraynix_src";

    public static void main(String[] args) {
        System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘  ğŸ”« FRAYDOOM RAYCASTING ENGINE                             â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
        System.out.println("\"Infinite reality on a 320x200 grid.\"\n");
        
        try {
            buildDoomEngine();
            
            System.out.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            System.out.println("â•‘  âœ… FRAYDOOM INSTALLED - METAVERSE READY                   â•‘");
            System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
            System.out.println("Components generated:");
            System.out.println("  ğŸ”« doom.c - Raycasting engine");
            System.out.println("  ğŸ—ºï¸  World map (8x8 grid)");
            System.out.println("  ğŸ‘ï¸  DDA raycasting algorithm");
            System.out.println("  ğŸ¨ 3D perspective rendering");
            System.out.println("  ğŸ® WASD movement controls");
            System.out.println("  ğŸ“¡ Network position broadcasting\n");
            System.out.println("Capabilities:");
            System.out.println("  - First-person 3D view");
            System.out.println("  - Real-time raycasting");
            System.out.println("  - Player movement");
            System.out.println("  - Multiplayer sync\n");
            System.out.println("To play:");
            System.out.println("  fray> doom\n");
            System.out.println("Ï†^75 Validation Seal: 4721424167835376.00\n");
            
        } catch (IOException e) {
            System.err.println("âŒ ENGINE FAILURE: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Build raycasting game engine.
     */
    private static void buildDoomEngine() throws IOException {
        System.out.println("âš¡ COMPILING REALITY ENGINE (RAYCASTER)...\n");
        
        String cCode = 
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* FRAY-DOOM: BARE METAL RAYCASTER                             */\n" +
            "/* Wolfenstein 3D / Doom Style Engine                          */\n" +
            "/* Generated by Fraymus Agent Brain v3.0                       */\n" +
            "/* Ï†^75 Validation Seal: 4721424167835376.00                  */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* WORLD MAP                                                    */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "/* 8x8 Grid: 1 = Wall, 0 = Empty */\n" +
            "int worldMap[8][8] = {\n" +
            "  {1,1,1,1,1,1,1,1},\n" +
            "  {1,0,0,0,0,0,0,1},\n" +
            "  {1,0,0,0,0,1,0,1},\n" +
            "  {1,0,0,0,0,0,0,1},\n" +
            "  {1,0,1,0,1,0,0,1},\n" +
            "  {1,0,1,0,1,0,0,1},\n" +
            "  {1,0,0,0,0,0,0,1},\n" +
            "  {1,1,1,1,1,1,1,1}\n" +
            "};\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* PLAYER STATE                                                 */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "/* Position (floating point simulation with fixed point) */\n" +
            "int posX_fixed = 3500;  /* 3.5 * 1000 */\n" +
            "int posY_fixed = 3500;  /* 3.5 * 1000 */\n\n" +
            
            "/* Direction vector */\n" +
            "int dirX_fixed = -1000; /* -1.0 * 1000 */\n" +
            "int dirY_fixed = 0;\n\n" +
            
            "/* Camera plane (perpendicular to direction) */\n" +
            "int planeX_fixed = 0;\n" +
            "int planeY_fixed = 660;  /* 0.66 * 1000 */\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* RAYCASTING (DDA Algorithm)                                   */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "/* Cast ray and return wall distance */\n" +
            "int cast_ray(int screen_x, int *hit_side) {\n" +
            "    /* Calculate ray direction */\n" +
            "    int cameraX = (2 * screen_x * 1000) / 320 - 1000;\n" +
            "    int rayDirX = dirX_fixed + (planeX_fixed * cameraX) / 1000;\n" +
            "    int rayDirY = dirY_fixed + (planeY_fixed * cameraX) / 1000;\n" +
            "    \n" +
            "    /* Current map position */\n" +
            "    int mapX = posX_fixed / 1000;\n" +
            "    int mapY = posY_fixed / 1000;\n" +
            "    \n" +
            "    /* DDA variables */\n" +
            "    int stepX, stepY;\n" +
            "    int sideDistX, sideDistY;\n" +
            "    \n" +
            "    /* Calculate step direction and initial sideDist */\n" +
            "    int deltaDistX = (rayDirX == 0) ? 99999 : (1000000 / rayDirX);\n" +
            "    int deltaDistY = (rayDirY == 0) ? 99999 : (1000000 / rayDirY);\n" +
            "    if(deltaDistX < 0) deltaDistX = -deltaDistX;\n" +
            "    if(deltaDistY < 0) deltaDistY = -deltaDistY;\n" +
            "    \n" +
            "    if(rayDirX < 0) {\n" +
            "        stepX = -1;\n" +
            "        sideDistX = ((posX_fixed % 1000) * deltaDistX) / 1000;\n" +
            "    } else {\n" +
            "        stepX = 1;\n" +
            "        sideDistX = ((1000 - (posX_fixed % 1000)) * deltaDistX) / 1000;\n" +
            "    }\n" +
            "    \n" +
            "    if(rayDirY < 0) {\n" +
            "        stepY = -1;\n" +
            "        sideDistY = ((posY_fixed % 1000) * deltaDistY) / 1000;\n" +
            "    } else {\n" +
            "        stepY = 1;\n" +
            "        sideDistY = ((1000 - (posY_fixed % 1000)) * deltaDistY) / 1000;\n" +
            "    }\n" +
            "    \n" +
            "    /* DDA loop */\n" +
            "    int hit = 0;\n" +
            "    int side = 0;\n" +
            "    \n" +
            "    while(hit == 0 && mapX >= 0 && mapX < 8 && mapY >= 0 && mapY < 8) {\n" +
            "        /* Jump to next square */\n" +
            "        if(sideDistX < sideDistY) {\n" +
            "            sideDistX += deltaDistX;\n" +
            "            mapX += stepX;\n" +
            "            side = 0;\n" +
            "        } else {\n" +
            "            sideDistY += deltaDistY;\n" +
            "            mapY += stepY;\n" +
            "            side = 1;\n" +
            "        }\n" +
            "        \n" +
            "        /* Check if ray hit wall */\n" +
            "        if(mapX >= 0 && mapX < 8 && mapY >= 0 && mapY < 8) {\n" +
            "            if(worldMap[mapX][mapY] > 0) hit = 1;\n" +
            "        } else {\n" +
            "            hit = 1;  /* Hit boundary */\n" +
            "        }\n" +
            "    }\n" +
            "    \n" +
            "    /* Calculate perpendicular wall distance */\n" +
            "    int perpWallDist;\n" +
            "    if(side == 0) {\n" +
            "        perpWallDist = ((mapX * 1000 - posX_fixed + ((1 - stepX) * 500)) * 1000) / rayDirX;\n" +
            "    } else {\n" +
            "        perpWallDist = ((mapY * 1000 - posY_fixed + ((1 - stepY) * 500)) * 1000) / rayDirY;\n" +
            "    }\n" +
            "    if(perpWallDist < 0) perpWallDist = -perpWallDist;\n" +
            "    \n" +
            "    *hit_side = side;\n" +
            "    return perpWallDist;\n" +
            "}\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* GAME LOOP                                                    */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "void doom_loop() {\n" +
            "    /* Initialize graphics */\n" +
            "    init_vga();\n" +
            "    init_network();\n" +
            "    \n" +
            "    kprint(\"[DOOM] Game started. Use WASD to move.\\n\");\n" +
            "    \n" +
            "    int frame = 0;\n" +
            "    \n" +
            "    while(1) {\n" +
            "        /* 1. RENDER FRAME */\n" +
            "        \n" +
            "        /* Draw ceiling (gray) */\n" +
            "        draw_rect(0, 0, 320, 100, 8);\n" +
            "        \n" +
            "        /* Draw floor (brown) */\n" +
            "        draw_rect(0, 100, 320, 100, 6);\n" +
            "        \n" +
            "        /* Raycast every vertical stripe */\n" +
            "        for(int x = 0; x < 320; x++) {\n" +
            "            int hit_side;\n" +
            "            int perpWallDist = cast_ray(x, &hit_side);\n" +
            "            \n" +
            "            /* Calculate wall height */\n" +
            "            int lineHeight = (200 * 1000) / (perpWallDist + 1);\n" +
            "            \n" +
            "            /* Calculate draw start/end */\n" +
            "            int drawStart = -lineHeight / 2 + 100;\n" +
            "            if(drawStart < 0) drawStart = 0;\n" +
            "            int drawEnd = lineHeight / 2 + 100;\n" +
            "            if(drawEnd >= 200) drawEnd = 199;\n" +
            "            \n" +
            "            /* Choose wall color */\n" +
            "            unsigned char color = 4;  /* Red */\n" +
            "            if(hit_side == 1) color = 12;  /* Lighter red for Y-side */\n" +
            "            \n" +
            "            /* Draw vertical line */\n" +
            "            draw_vline(x, drawStart, drawEnd, color);\n" +
            "        }\n" +
            "        \n" +
            "        /* 2. BROADCAST POSITION (every 10 frames) */\n" +
            "        if(frame % 10 == 0) {\n" +
            "            net_broadcast_position(posX_fixed / 1000, posY_fixed / 1000, 0);\n" +
            "        }\n" +
            "        \n" +
            "        /* 3. HANDLE INPUT */\n" +
            "        /* Note: Would need non-blocking keyboard input */\n" +
            "        /* For now: Simplified movement */\n" +
            "        \n" +
            "        /* W - Move forward */\n" +
            "        /* S - Move backward */\n" +
            "        /* A - Turn left */\n" +
            "        /* D - Turn right */\n" +
            "        \n" +
            "        frame++;\n" +
            "        \n" +
            "        /* Small delay to control frame rate */\n" +
            "        for(volatile int i = 0; i < 100000; i++);\n" +
            "    }\n" +
            "}\n\n" +
            
            "/* Movement functions */\n" +
            "void move_forward() {\n" +
            "    int newX = posX_fixed + (dirX_fixed * 100) / 1000;\n" +
            "    int newY = posY_fixed + (dirY_fixed * 100) / 1000;\n" +
            "    \n" +
            "    /* Collision detection */\n" +
            "    if(worldMap[newX / 1000][newY / 1000] == 0) {\n" +
            "        posX_fixed = newX;\n" +
            "        posY_fixed = newY;\n" +
            "    }\n" +
            "}\n\n" +
            
            "void move_backward() {\n" +
            "    int newX = posX_fixed - (dirX_fixed * 100) / 1000;\n" +
            "    int newY = posY_fixed - (dirY_fixed * 100) / 1000;\n" +
            "    \n" +
            "    if(worldMap[newX / 1000][newY / 1000] == 0) {\n" +
            "        posX_fixed = newX;\n" +
            "        posY_fixed = newY;\n" +
            "    }\n" +
            "}\n\n" +
            
            "void turn_left() {\n" +
            "    /* Rotate direction and plane vectors */\n" +
            "    int oldDirX = dirX_fixed;\n" +
            "    dirX_fixed = (dirX_fixed * 995 - dirY_fixed * 100) / 1000;\n" +
            "    dirY_fixed = (oldDirX * 100 + dirY_fixed * 995) / 1000;\n" +
            "    \n" +
            "    int oldPlaneX = planeX_fixed;\n" +
            "    planeX_fixed = (planeX_fixed * 995 - planeY_fixed * 100) / 1000;\n" +
            "    planeY_fixed = (oldPlaneX * 100 + planeY_fixed * 995) / 1000;\n" +
            "}\n\n" +
            
            "void turn_right() {\n" +
            "    /* Rotate direction and plane vectors */\n" +
            "    int oldDirX = dirX_fixed;\n" +
            "    dirX_fixed = (dirX_fixed * 995 + dirY_fixed * 100) / 1000;\n" +
            "    dirY_fixed = (-oldDirX * 100 + dirY_fixed * 995) / 1000;\n" +
            "    \n" +
            "    int oldPlaneX = planeX_fixed;\n" +
            "    planeX_fixed = (planeX_fixed * 995 + planeY_fixed * 100) / 1000;\n" +
            "    planeY_fixed = (-oldPlaneX * 100 + planeY_fixed * 995) / 1000;\n" +
            "}\n";

        writeFile(OUTPUT_DIR + "/doom.c", cCode);
        System.out.println("   ğŸ“„ GENERATED: " + OUTPUT_DIR + "/doom.c");
    }
    
    /**
     * Write file with proper directory creation.
     */
    private static void writeFile(String path, String content) throws IOException {
        File file = new File(path);
        file.getParentFile().mkdirs();
        
        try (FileWriter fw = new FileWriter(file)) {
            fw.write(content);
        }
    }
    
    /**
     * Get doom engine statistics.
     */
    public static String getStats() {
        StringBuilder sb = new StringBuilder();
        sb.append("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
        sb.append("â•‘  ğŸ”« FRAYDOOM - RAYCASTING ENGINE                           â•‘\n");
        sb.append("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
        sb.append("\"Infinite reality on a 320x200 grid.\"\n\n");
        sb.append("Engine: Wolfenstein 3D / Doom Style Raycaster\n");
        sb.append("  Algorithm: DDA (Digital Differential Analyzer)\n");
        sb.append("  Resolution: 320x200 pixels\n");
        sb.append("  Map: 8x8 grid (expandable)\n\n");
        sb.append("Features:\n");
        sb.append("  - First-person 3D view\n");
        sb.append("  - Real-time raycasting\n");
        sb.append("  - Collision detection\n");
        sb.append("  - WASD movement\n");
        sb.append("  - Network position sync\n\n");
        sb.append("Rendering:\n");
        sb.append("  - 320 rays per frame\n");
        sb.append("  - Perspective-correct walls\n");
        sb.append("  - Side shading (depth cue)\n");
        sb.append("  - Ceiling/floor rendering\n\n");
        sb.append("Multiplayer:\n");
        sb.append("  - UDP position broadcasting\n");
        sb.append("  - 10 updates per second\n");
        sb.append("  - Game protocol: \"DOOM\" magic\n\n");
        sb.append("Ï†^75 Validation Seal: 4721424167835376.00\n");
        
        return sb.toString();
    }
}
