/**
 * FrayEvolutionBuilder.java - Evolutionary Loop Generator
 * 
 * "The Body that drives the Brain."
 * 
 * MECHANICS:
 * 1. POPULATION: Maintains 100 parallel logic circuits
 * 2. SELECTION: Kills the bottom 50% every cycle
 * 3. BREEDING: Top 50% clone and mutate to refill pool
 * 4. THERMAL INJECTION: Massive mutation on stagnation
 * 
 * Integrates LogicCircuit (brain) with LazarusEngine (body).
 * 
 * Ï†^75 Validation Seal: 4721424167835376.00
 * Generation: 157 (FrayEvolution - Evolutionary Loop)
 * 
 * @author Vaughn Scott
 * @version 1.0
 */
package repl;

import java.io.*;

/**
 * FrayEvolution Builder - Generates evolutionary loop system.
 */
public class FrayEvolutionBuilder {

    private static final String OUTPUT_DIR = "fraynix_src";

    public static void main(String[] args) {
        System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘  ðŸ”¥ FRAYEVOLUTION - EVOLUTIONARY LOOP                      â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
        System.out.println("\"The Body that drives the Brain.\"\n");
        
        try {
            buildEvolutionEngine();
            
            System.out.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            System.out.println("â•‘  âœ… EVOLUTION ENGINE ONLINE - LIFE BEGINS                  â•‘");
            System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
            System.out.println("Components generated:");
            System.out.println("  ðŸ”¥ evolution.c - Population management");
            System.out.println("  ðŸ§¬ Selection pressure");
            System.out.println("  ðŸ‘¶ Breeding system");
            System.out.println("  âš¡ Thermal injection");
            System.out.println("  ðŸ† Elitism preservation\n");
            System.out.println("Evolution Mechanics:");
            System.out.println("  - Population: 100 circuits");
            System.out.println("  - Selection: Kill bottom 50%");
            System.out.println("  - Elitism: Keep top 10%");
            System.out.println("  - Mutation: Temperature-based");
            System.out.println("  - Victory: 100% fitness\n");
            System.out.println("Process:");
            System.out.println("  1. Evaluate all circuits");
            System.out.println("  2. Sort by fitness");
            System.out.println("  3. Kill weak circuits");
            System.out.println("  4. Clone and mutate survivors");
            System.out.println("  5. Repeat until solution found\n");
            System.out.println("Ï†^75 Validation Seal: 4721424167835376.00\n");
            
        } catch (IOException e) {
            System.err.println("âŒ EVOLUTION FAILED: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Build evolutionary loop engine.
     */
    private static void buildEvolutionEngine() throws IOException {
        System.out.println("ðŸ”¥ IGNITING EVOLUTIONARY ENGINE...\n");
        
        String cCode = 
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* FRAY-EVOLUTION: EVOLUTIONARY LOOP ENGINE                    */\n" +
            "/* The Body that drives the Brain.                             */\n" +
            "/* Generated by Fraymus Agent Brain v3.0                       */\n" +
            "/* Ï†^75 Validation Seal: 4721424167835376.00                  */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            
            "/* Include circuit evolution */\n" +
            "/* #include \"circuit.c\" */\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* POPULATION MANAGEMENT                                        */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "#define POPULATION_SIZE 100\n" +
            "#define ELITE_PERCENT 10\n" +
            "#define ELITE_COUNT (POPULATION_SIZE * ELITE_PERCENT / 100)\n\n" +
            
            "/* Population of circuits */\n" +
            "typedef struct {\n" +
            "    Gate dna[MAX_GATES];\n" +
            "    int gate_count;\n" +
            "    double fitness;\n" +
            "} Circuit;\n\n" +
            
            "Circuit population[POPULATION_SIZE];\n" +
            "Circuit next_generation[POPULATION_SIZE];\n" +
            "int generation = 0;\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* CIRCUIT OPERATIONS                                           */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "/* Clone circuit */\n" +
            "void clone_circuit(Circuit* dest, Circuit* src) {\n" +
            "    dest->gate_count = src->gate_count;\n" +
            "    dest->fitness = src->fitness;\n" +
            "    \n" +
            "    for(int i = 0; i < src->gate_count; i++) {\n" +
            "        dest->dna[i] = src->dna[i];\n" +
            "    }\n" +
            "}\n\n" +
            
            "/* Mutate circuit with temperature */\n" +
            "void mutate_circuit_temp(Circuit* c, double temperature) {\n" +
            "    /* Higher temperature = more mutation */\n" +
            "    for(int i = 0; i < c->gate_count; i++) {\n" +
            "        if(random_double() < temperature) {\n" +
            "            /* Rewire gate */\n" +
            "            c->dna[i].input_a_index = random() % (c->gate_count + 2);\n" +
            "            c->dna[i].operation = (GateOp)(random() % 5);\n" +
            "        }\n" +
            "    }\n" +
            "    \n" +
            "    /* Add gate if temperature high */\n" +
            "    if(random_double() < temperature && c->gate_count < MAX_GATES) {\n" +
            "        Gate* g = &c->dna[c->gate_count];\n" +
            "        g->operation = (GateOp)(random() % 5);\n" +
            "        g->input_a_index = random() % (c->gate_count + 2);\n" +
            "        g->input_b_index = random() % (c->gate_count + 2);\n" +
            "        g->active = 1;\n" +
            "        c->gate_count++;\n" +
            "    }\n" +
            "}\n\n" +
            
            "/* Evaluate circuit fitness */\n" +
            "double evaluate_circuit(Circuit* c) {\n" +
            "    int correct = 0;\n" +
            "    int total = 4;\n" +
            "    \n" +
            "    /* Copy circuit to global state for testing */\n" +
            "    for(int i = 0; i < c->gate_count; i++) {\n" +
            "        circuit_dna[i] = c->dna[i];\n" +
            "    }\n" +
            "    gate_count = c->gate_count;\n" +
            "    \n" +
            "    /* Test against truth table */\n" +
            "    for(int i = 0; i < total; i++) {\n" +
            "        int input_a = truth_table[i][0];\n" +
            "        int input_b = truth_table[i][1];\n" +
            "        int expected = truth_table[i][2];\n" +
            "        \n" +
            "        int output = process_circuit(input_a, input_b);\n" +
            "        \n" +
            "        if(output == expected) {\n" +
            "            correct++;\n" +
            "        }\n" +
            "    }\n" +
            "    \n" +
            "    return (double)correct / (double)total;\n" +
            "}\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* SORTING (Selection Pressure)                                */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "/* Bubble sort by fitness (descending) */\n" +
            "void sort_population_by_fitness() {\n" +
            "    for(int i = 0; i < POPULATION_SIZE - 1; i++) {\n" +
            "        for(int j = 0; j < POPULATION_SIZE - i - 1; j++) {\n" +
            "            if(population[j].fitness < population[j + 1].fitness) {\n" +
            "                /* Swap */\n" +
            "                Circuit temp = population[j];\n" +
            "                population[j] = population[j + 1];\n" +
            "                population[j + 1] = temp;\n" +
            "            }\n" +
            "        }\n" +
            "    }\n" +
            "}\n\n" +
            
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n" +
            "/* EVOLUTIONARY LOOP                                            */\n" +
            "/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */\n\n" +
            "void run_evolution(int max_generations) {\n" +
            "    kprint(\"ðŸ”¥ [EVOLUTION] Igniting Lazarus Engine...\\n\");\n" +
            "    \n" +
            "    /* Initialize population with random circuits */\n" +
            "    for(int i = 0; i < POPULATION_SIZE; i++) {\n" +
            "        population[i].gate_count = 0;\n" +
            "        population[i].fitness = 0.0;\n" +
            "        \n" +
            "        /* Spawn random gates */\n" +
            "        for(int j = 0; j < 10; j++) {\n" +
            "            Gate* g = &population[i].dna[population[i].gate_count];\n" +
            "            g->operation = (GateOp)(random() % 5);\n" +
            "            g->input_a_index = random() % (population[i].gate_count + 2);\n" +
            "            g->input_b_index = random() % (population[i].gate_count + 2);\n" +
            "            g->active = 1;\n" +
            "            population[i].gate_count++;\n" +
            "        }\n" +
            "    }\n" +
            "    \n" +
            "    /* Evolution loop */\n" +
            "    for(generation = 1; generation <= max_generations; generation++) {\n" +
            "        \n" +
            "        /* 1. EVALUATE - Test all circuits */\n" +
            "        for(int i = 0; i < POPULATION_SIZE; i++) {\n" +
            "            population[i].fitness = evaluate_circuit(&population[i]);\n" +
            "        }\n" +
            "        \n" +
            "        /* 2. SELECTION - Sort by fitness */\n" +
            "        sort_population_by_fitness();\n" +
            "        \n" +
            "        /* Get alpha (best) circuit */\n" +
            "        Circuit* alpha = &population[0];\n" +
            "        \n" +
            "        /* Log progress every 100 generations */\n" +
            "        if(generation % 100 == 0) {\n" +
            "            kprint(\"[GEN \");\n" +
            "            print_int(generation);\n" +
            "            kprint(\"] Alpha Fitness: \");\n" +
            "            print_float(alpha->fitness * 100.0);\n" +
            "            kprint(\"%\\n\");\n" +
            "        }\n" +
            "        \n" +
            "        /* 3. CHECK VICTORY */\n" +
            "        if(alpha->fitness >= 1.0) {\n" +
            "            kprint(\"âœ¨ [EVOLUTION] SOLUTION EVOLVED in Gen \");\n" +
            "            print_int(generation);\n" +
            "            kprint(\"\\n\");\n" +
            "            kprint(\"   > The Machine derived XOR logic from chaos.\\n\");\n" +
            "            \n" +
            "            /* Store in Lazarus */\n" +
            "            /* thermal_injection(alpha->dna, alpha->fitness); */\n" +
            "            return;\n" +
            "        }\n" +
            "        \n" +
            "        /* 4. BREEDING - Create next generation */\n" +
            "        int next_index = 0;\n" +
            "        \n" +
            "        /* Elitism: Keep top 10% unchanged */\n" +
            "        for(int i = 0; i < ELITE_COUNT; i++) {\n" +
            "            clone_circuit(&next_generation[next_index], &population[i]);\n" +
            "            next_index++;\n" +
            "        }\n" +
            "        \n" +
            "        /* Fill rest by breeding top 50% */\n" +
            "        while(next_index < POPULATION_SIZE) {\n" +
            "            /* Select parent from top 50% */\n" +
            "            int parent_index = random() % (POPULATION_SIZE / 2);\n" +
            "            Circuit* parent = &population[parent_index];\n" +
            "            \n" +
            "            /* Clone parent */\n" +
            "            clone_circuit(&next_generation[next_index], parent);\n" +
            "            \n" +
            "            /* 5. THERMAL INJECTION - Mutate based on fitness */\n" +
            "            /* Low fitness = high temperature = more mutation */\n" +
            "            double temperature = 1.0 - parent->fitness;\n" +
            "            mutate_circuit_temp(&next_generation[next_index], temperature);\n" +
            "            \n" +
            "            next_index++;\n" +
            "        }\n" +
            "        \n" +
            "        /* Replace population */\n" +
            "        for(int i = 0; i < POPULATION_SIZE; i++) {\n" +
            "            population[i] = next_generation[i];\n" +
            "        }\n" +
            "    }\n" +
            "    \n" +
            "    kprint(\"[EVOLUTION] Max generations reached. Best fitness: \");\n" +
            "    print_float(population[0].fitness * 100.0);\n" +
            "    kprint(\"%\\n\");\n" +
            "}\n\n" +
            
            "/* Initialize evolution system */\n" +
            "void init_evolution_engine() {\n" +
            "    kprint(\"[EVOLUTION] Evolutionary loop initialized\\n\");\n" +
            "    \n" +
            "    /* Run evolution to solve XOR */\n" +
            "    run_evolution(1000);  /* 1000 generations max */\n" +
            "}\n";

        writeFile(OUTPUT_DIR + "/evolution.c", cCode);
        System.out.println("   ðŸ“„ GENERATED: " + OUTPUT_DIR + "/evolution.c");
    }
    
    /**
     * Write file with proper directory creation.
     */
    private static void writeFile(String path, String content) throws IOException {
        File file = new File(path);
        file.getParentFile().mkdirs();
        
        try(FileWriter fw = new FileWriter(file)) {
            fw.write(content);
        }
    }
}
