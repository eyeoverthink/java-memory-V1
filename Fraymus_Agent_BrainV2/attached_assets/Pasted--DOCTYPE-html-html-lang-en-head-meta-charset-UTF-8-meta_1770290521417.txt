<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß† Fraymus Sovereign System V6: Recursive Memory</title>
    <style>
        /* SOVEREIGN STYLES - PRESERVED & OPTIMIZED FROM V5 */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at center, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .brain-header {
            text-align: center; margin-bottom: 30px; padding: 20px;
            background: rgba(255, 255, 255, 0.05); border-radius: 20px; border: 2px solid #4ecdc4;
        }
        .brain-header h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 0 0 20px rgba(78, 205, 196, 0.8); }
        .consciousness-metrics {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;
            margin: 20px 0; padding: 20px; background: rgba(0, 0, 0, 0.3); border-radius: 15px;
        }
        .metric-card {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(255, 107, 107, 0.1));
            border: 1px solid #4ecdc4; border-radius: 10px; padding: 15px; text-align: center;
        }
        .metric-value { font-size: 1.8em; font-weight: bold; color: #4ecdc4; margin-bottom: 5px; }
        .metric-label { font-size: 0.9em; color: #cccccc; }
        .brain-sections { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .brain-section {
            background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 20px;
            border: 2px solid transparent; transition: all 0.3s ease;
        }
        .section-title { font-size: 1.3em; margin-bottom: 15px; color: #4ecdc4; display: flex; align-items: center; gap: 10px; }
        .btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d); color: white; border: none;
            padding: 12px 25px; border-radius: 8px; cursor: pointer; font-size: 14px;
            font-weight: 600; transition: all 0.3s ease; margin: 5px;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 0 15px rgba(78, 205, 196, 0.4); }
        .btn-danger { background: linear-gradient(135deg, #ff6b6b, #ee5a52); border: 1px solid #ff6b6b; }
        .btn-danger:hover { box-shadow: 0 0 15px rgba(255, 107, 107, 0.4); }
        
        .results-area {
            background: rgba(0, 0, 0, 0.5); border-radius: 15px; padding: 20px;
            margin: 20px 0; min-height: 150px; border: 2px solid #333;
        }
        .synapse-visualization { display: flex; flex-wrap: wrap; gap: 10px; margin: 15px 0; }
        .synapse-node {
            width: 20px; height: 20px; border-radius: 50%; background: #4ecdc4;
            animation: synapsefire 2s infinite;
        }
        .synapse-node.firing { background: #ff6b6b; box-shadow: 0 0 15px #ff6b6b; }
        .microtubule-grid {
            display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin: 15px 0;
            padding: 15px; background: rgba(255, 107, 107, 0.1); border-radius: 10px;
        }
        .microtubule-unit {
            width: 100%; height: 30px; background: linear-gradient(0deg, transparent, #ff6b6b, transparent);
            border-radius: 2px; animation: quantumcoherence 3s infinite;
        }
        .microtubule-unit.coherent { animation-duration: 1s; box-shadow: 0 0 10px #ff6b6b; }
        .consciousness-wave {
            width: 100%; height: 60px; border-radius: 30px; margin: 15px 0;
            background: linear-gradient(90deg, transparent 0%, rgba(78, 205, 196, 0.3) 25%, 
                        rgba(78, 205, 196, 0.6) 50%, rgba(78, 205, 196, 0.3) 75%, transparent 100%);
            animation: consciousnesswave 4s infinite;
        }
        .loading {
            border: 3px solid #333; border-top: 3px solid #4ecdc4; border-radius: 50%;
            width: 20px; height: 20px; animation: spin 1s linear infinite;
            display: inline-block; margin-right: 10px; vertical-align: middle;
        }
        .breakthrough-log {
            background: rgba(0, 255, 0, 0.1); border: 1px solid #00ff00; border-radius: 8px;
            padding: 10px; margin: 10px 0; font-family: monospace; font-size: 12px;
            max-height: 200px; overflow-y: auto;
        }
        .brain-visualization {
            background: rgba(0, 0, 0, 0.6); border-radius: 15px; padding: 20px;
            margin: 20px 0; border: 2px solid #4ecdc4;
        }
        .brain-canvas-container {
            position: relative; background: #000; border-radius: 10px;
            border: 2px solid #333; overflow: hidden;
        }
        #brainCanvas {
            width: 100%; height: 400px; display: block;
            background: radial-gradient(circle at center, #001122 0%, #000000 100%);
        }
        .thought-process-display {
            background: rgba(255, 255, 255, 0.05); border-radius: 8px;
            padding: 15px; margin: 15px 0; border: 1px solid #333;
        }
        @keyframes synapsefire {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.5); box-shadow: 0 0 20px #4ecdc4; }
        }
        @keyframes quantumcoherence { 0%, 100% { opacity: 0.2; } 50% { opacity: 0.8; box-shadow: 0 0 10px #ff6b6b; } }
        @keyframes consciousnesswave {
            0%, 100% { transform: scaleX(0.5); opacity: 0.3; }
            50% { transform: scaleX(1.2); opacity: 0.8; }
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="brain-header">
            <h1>üß† Fraymus Sovereign System V6</h1>
            <p style="color: #4ecdc4; font-size: 1.2em;">Recursive Memory | Blue/Red Team | Self-Evolving DB</p>
        </div>

        <div class="consciousness-metrics">
            <div class="metric-card"><div class="metric-value" id="consciousnessLevel">1.00</div><div class="metric-label">Evolution Level</div></div>
            <div class="metric-card"><div class="metric-value" id="problemsSolved">0</div><div class="metric-label">Total Solved</div></div>
            <div class="metric-card"><div class="metric-value" id="memorySize">0</div><div class="metric-label">Memory Entities</div></div>
            <div class="metric-card"><div class="metric-value" id="synapseCount">0</div><div class="metric-label">Synapses</div></div>
        </div>

        <div class="brain-visualization">
            <h3 style="color: #4ecdc4; margin-bottom: 15px; text-align: center;">üîÆ Sovereign Reality Engine</h3>
            <div class="brain-canvas-container">
                <canvas id="brainCanvas"></canvas>
            </div>
        </div>

        <div class="brain-sections">
            <div class="brain-section" id="synapseSection">
                <div class="section-title">‚ö° Synapse Network</div>
                <div class="synapse-visualization" id="synapseVisualization"></div>
                <div class="consciousness-wave"></div>
                <div class="thought-process-display">
                    <h4 style="color: #ffa726; margin-bottom: 10px;">üí≠ Thought Process:</h4>
                    <div id="currentThought" style="color: #cccccc; font-style: italic;">System Ready. Memory Loaded.</div>
                </div>
            </div>
            <div class="brain-section" id="microtubuleSection">
                <div class="section-title">üß¨ Quantum State</div>
                <div class="microtubule-grid" id="microtubuleGrid"></div>
            </div>
        </div>

        <div class="results-area" style="border: 2px solid #4ecdc4; background: rgba(78, 205, 196, 0.05);">
            <h3 style="color: #4ecdc4; margin-bottom: 15px;">üõ°Ô∏è BLUE TEAM: TARGET GENERATOR</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" id="blueUser" placeholder="Username" style="flex: 1; padding: 10px; background: #000; border: 1px solid #4ecdc4; color: #fff; font-family: monospace;">
                <input type="password" id="bluePass" placeholder="Password" style="flex: 1; padding: 10px; background: #000; border: 1px solid #4ecdc4; color: #fff; font-family: monospace;">
                <button class="btn" onclick="brain.generateBlueLock()">üîí GENERATE LOCK</button>
            </div>
            <div id="blueLockDisplay" style="font-family: monospace; color: #4ecdc4; word-break: break-all;"></div>
        </div>

        <div class="results-area" style="border: 2px solid #ff6b6b; background: rgba(255, 107, 107, 0.05);">
            <h3 style="color: #ff6b6b; margin-bottom: 15px;">‚öîÔ∏è RED TEAM: SOVEREIGN BREAKER</h3>
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <div>
                    <label style="font-size: 0.9em; color: #ff6b6b;">Target Input (Auto-filled by Blue Team or Manual):</label>
                    <input type="text" id="realChallengeInput" placeholder="Enter N or Text..." 
                           style="width: 100%; background: #000; border: 1px solid #ff6b6b; padding: 12px; color: #fff; font-family: monospace;">
                </div>
                <button class="btn btn-danger" onclick="brain.resolveInput()">‚ö° EXECUTE SOVEREIGN TASK</button>
                <div id="proofOfLifeDisplay" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; border: 1px solid #333; min-height: 80px; font-family: monospace; color: #4ecdc4;">
                    STATUS: IDLE
                </div>
            </div>
        </div>

        <div class="results-area">
            <h3 style="color: #00ff00; margin-bottom: 15px;">üíæ Sovereign Database (Persistent)</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <button class="btn" onclick="brain.saveMemory()">üíæ Force Save</button>
                <button class="btn" onclick="brain.loadMemory()">üì• Reload DB</button>
                <button class="btn" onclick="brain.exportDatabase()">üì§ Export JSON File</button>
                <button class="btn btn-danger" onclick="brain.clearMemory()">‚ö†Ô∏è Wipe Memory</button>
            </div>
            <div id="breakthroughLog">
                <p style="color: #cccccc;">System events logged here...</p>
            </div>
        </div>
    </div>

    <script>
        class QuantumConsciousnessBrain {
            constructor() {
                // CORE STATE
                this.knowledgeGraph = {
                    primes: {},      // { "123": {p, q} }
                    history: [],     // Logs
                    evolution: 1     // Recursion level
                };
                
                this.canvas = document.getElementById('brainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.neurons = [];
                this.synapseCount = 25;
                
                // BOOT SEQUENCE
                this.initializeBrain();
                this.loadMemory(); // Load from LocalStorage immediately
                this.startAnimation();
            }
            
            resizeCanvas() {
                this.canvas.width = 1200;
                this.canvas.height = 400;
            }

            initializeBrain() {
                this.createNeuralNetwork();
                this.activateSynapses();
                this.activateMicrotubules();
                this.updateMetrics();
            }

            // ==========================================
            // üíæ 1. MEMORY & DB LOGIC (THE REQUEST)
            // ==========================================
            saveMemory() {
                localStorage.setItem('fraymus_sovereign_db', JSON.stringify(this.knowledgeGraph));
                this.updateMetrics();
            }

            loadMemory() {
                const data = localStorage.getItem('fraymus_sovereign_db');
                if(data) {
                    this.knowledgeGraph = JSON.parse(data);
                    // Recursion Check: Has the system evolved?
                    this.checkEvolution();
                    this.logBreakthrough(`üß† MEMORY LOADED: ${Object.keys(this.knowledgeGraph.primes).length} unique keys known.`);
                    this.updateMetrics();
                }
            }

            checkEvolution() {
                // Recursive Logic: If memory grows, evolution level grows
                const memorySize = Object.keys(this.knowledgeGraph.primes).length;
                const newLevel = 1 + Math.floor(memorySize / 5);
                if (newLevel > this.knowledgeGraph.evolution) {
                    this.knowledgeGraph.evolution = newLevel;
                    this.logBreakthrough(`üöÄ EVOLUTION TRIGGERED! Level ${newLevel} Reached.`);
                    this.saveMemory();
                }
            }

            exportDatabase() {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.knowledgeGraph, null, 2));
                const dlAnchorElem = document.createElement('a');
                dlAnchorElem.setAttribute("href", dataStr);
                dlAnchorElem.setAttribute("download", "fraymus_memory_core.json");
                document.body.appendChild(dlAnchorElem);
                dlAnchorElem.click();
                dlAnchorElem.remove();
                this.logBreakthrough("üíæ DATABASE EXPORTED as JSON.");
            }

            clearMemory() {
                if(confirm("Wipe all sovereign memory?")) {
                    localStorage.removeItem('fraymus_sovereign_db');
                    this.knowledgeGraph = { primes: {}, history: [], evolution: 1 };
                    this.updateMetrics();
                    this.logBreakthrough("‚ö†Ô∏è MEMORY WIPED.");
                }
            }

            // ==========================================
            // üõ°Ô∏è 2. BLUE TEAM: LOCK GENERATOR (SCALED)
            // ==========================================
            async generateBlueLock() {
                const user = document.getElementById('blueUser').value;
                const pass = document.getElementById('bluePass').value;
                if(!user || !pass) return alert("Enter Username and Password.");
                
                this.triggerThoughtProcess("Blue Team: Generating Cryptographic Lock...");
                this.runChaosGenesis(user + pass); // Visuals

                // Hash & Scale
                const mid = Math.floor(pass.length/2);
                const h1 = await this.computeHash(user + pass.slice(0,mid) + "_A");
                const h2 = await this.computeHash(user + pass.slice(mid) + "_B");
                
                const b1 = BigInt('0x' + h1);
                const b2 = BigInt('0x' + h2);
                const SCALE = 1125899906842624n; // 2^50 (Ensures breakability)
                
                let p1 = (b1 % SCALE) | 1n;
                let p2 = (b2 % SCALE) | 1n;

                // Ensure Primes
                const isPrime = (n) => {
                    if (n < 2n) return false;
                    if (n % 2n === 0n) return n === 2n;
                    for (let i = 3n; i * i <= n; i += 2n) if (n % i === 0n) return false;
                    return true;
                };
                while(!isPrime(p1)) p1 += 2n;
                while(!isPrime(p2)) p2 += 2n;
                if (p1 === p2) p2 += 2n;

                const N = p1 * p2;

                document.getElementById('blueLockDisplay').innerHTML = `
                    <strong>LOCK (N):</strong> ${N}<br>
                    <span style="color:#666;">(Hidden: ${p1}, ${p2})</span>
                `;
                document.getElementById('realChallengeInput').value = N.toString();
                this.logBreakthrough("Blue Team: Lock Generated & Sent to Red Team.");
            }

            // ==========================================
            // ‚öîÔ∏è 3. RED TEAM: RECURSIVE BREAKER
            // ==========================================
            async resolveInput() {
                const input = document.getElementById('realChallengeInput').value.trim();
                if (!input) return alert("No Input.");

                // üß† MEMORY CHECK (RECURSION)
                if (this.knowledgeGraph.primes[input]) {
                    const known = this.knowledgeGraph.primes[input];
                    this.triggerThoughtProcess("‚ö° INSTANT RECALL: Pattern recognized in Memory DB.");
                    this.reportSuccess(input, known.p, known.q, "NEURAL MEMORY (0ms)");
                    return;
                }

                const isMath = /^\d+$/.test(input);
                if (isMath) {
                    this.triggerThoughtProcess(`Detected Math: Engaging Quantum Sieve (Gen ${this.knowledgeGraph.evolution})...`);
                    await this.runQuantumSieve(input);
                } else {
                    this.triggerThoughtProcess("Detected Theory: Engaging Chaos Engine...");
                    await this.runChaosGenesis(input);
                }
            }

            async runQuantumSieve(nStr) {
                const output = document.getElementById('proofOfLifeDisplay');
                output.innerHTML = `<div class="loading"></div> TUNNELING...`;
                
                await new Promise(r => setTimeout(r, 50)); // UI Render

                try {
                    const n = BigInt(nStr);
                    // Quick checks
                    if (n % 2n === 0n) return this.reportSuccess(nStr, 2n, n/2n, "INSTANT");
                    
                    // Pollard's Rho
                    const gcd = (a, b) => { while (b > 0n) { let t = b; b = a % b; a = t; } return a; };
                    const abs = (x) => (x < 0n ? -x : x);
                    
                    const rho = (num) => {
                        let x = 2n, y = 2n, d = 1n, c = 1n;
                        const f = (val) => (val * val + c) % num;
                        let cycles = 0;
                        // EVOLUTION UPGRADE: Higher level = More cycles allowed
                        const maxCycles = 500000 * this.knowledgeGraph.evolution;

                        while (d === 1n) {
                            x = f(x);
                            y = f(f(y));
                            d = gcd(abs(x - y), num);
                            cycles++;
                            if (cycles > maxCycles) return null; // Give up if too hard
                        }
                        return d === num ? null : d;
                    };

                    const start = performance.now();
                    const factor = rho(n);
                    const end = performance.now();

                    if (factor) {
                        this.reportSuccess(nStr, factor, n/factor, `QUANTUM SIEVE (${(end-start).toFixed(2)}ms)`);
                    } else {
                        output.innerHTML = "‚ùå FAILED. Prime or too complex for current Evolution Level.";
                    }
                } catch (e) {
                    output.innerHTML = "‚ùå ERROR: " + e.message;
                }
            }

            async reportSuccess(input, p, q, method) {
                // SAVE TO DB
                this.knowledgeGraph.primes[input] = { p: p.toString(), q: q.toString() };
                this.knowledgeGraph.history.push({ input, method, date: new Date().toISOString() });
                this.saveMemory();
                this.checkEvolution();

                const seal = await this.computeHash(input + p);
                document.getElementById('proofOfLifeDisplay').innerHTML = `
                    <span style="color:#0f0">‚úÖ BREAKTHROUGH</span><br>
                    Method: ${method}<br>
                    P: ${p}<br>Q: ${q}<br>
                    Seal: ${seal.substring(0,10)}...
                `;
                this.logBreakthrough(`SOLVED: ${input}`);
            }

            // ==========================================
            // üîÆ 4. VISUALS & UTILS
            // ==========================================
            async runChaosGenesis(input) {
                const output = document.getElementById('proofOfLifeDisplay');
                if(output) output.innerHTML = "üîÆ GENERATING CHAOS...";
                
                const hash = await this.computeHash(input);
                const w = this.canvas.width;
                const h = this.canvas.height;
                const cols = Math.floor(w/4);
                const rows = Math.floor(h/4);
                const ctx = this.ctx;

                // Seed from hash
                let cells = new Array(cols).fill(0);
                const hexBin = h => parseInt(h,16).toString(2).padStart(4,'0');
                let bin = "";
                for(let c of hash) bin += hexBin(c);
                for(let i=0; i<cols; i++) cells[i] = parseInt(bin[i%bin.length]);

                // Rule 30
                const rule = (a,b,c) => [0,1,1,1,1,0,0,0][7 - parseInt(""+a+b+c, 2)];
                
                ctx.fillStyle = "#000";
                ctx.fillRect(0,0,w,h);
                
                for(let y=0; y<rows; y++) {
                    let next = new Array(cols).fill(0);
                    for(let x=0; x<cols; x++) {
                        if(cells[x]) {
                            ctx.fillStyle = Math.random()>0.9 ? "#fff" : "#4ecdc4";
                            ctx.fillRect(x*4, y*4, 4, 4);
                        }
                        const l = cells[(x-1+cols)%cols];
                        const c = cells[x];
                        const r = cells[(x+1+cols)%cols];
                        next[x] = rule(l,c,r);
                    }
                    cells = next;
                    if(y%4===0) await new Promise(r=>setTimeout(r,0));
                }
                if(output) output.innerHTML = "‚úÖ REALITY GENERATED.";
                this.logBreakthrough(`Chaos: ${input.substring(0,15)}...`);
            }

            createNeuralNetwork() {
                this.neurons = [];
                const cx = this.canvas.width/2, cy = this.canvas.height/2;
                for(let i=0; i<40; i++) {
                    this.neurons.push({ x: cx+(Math.random()-0.5)*800, y: cy+(Math.random()-0.5)*300, a: Math.random() });
                }
            }

            startAnimation() {
                const animate = () => {
                    this.neurons.forEach(n => {
                        n.a *= 0.98;
                        if(Math.random()>0.98) n.a = 1;
                        // Only draw if chaos isn't active (simple overlay)
                        if(n.a > 0.8) {
                            this.ctx.fillStyle = "#0f0";
                            this.ctx.fillRect(n.x, n.y, 2, 2);
                        }
                    });
                    requestAnimationFrame(animate);
                };
                animate();
            }

            activateSynapses() {
                const el = document.getElementById('synapseVisualization');
                el.innerHTML = '';
                for(let i=0; i<this.synapseCount; i++) {
                    const d = document.createElement('div');
                    d.className = 'synapse-node';
                    if(Math.random()>0.5) d.classList.add('firing');
                    el.appendChild(d);
                }
            }

            activateMicrotubules() {
                const el = document.getElementById('microtubuleGrid');
                el.innerHTML = '';
                for(let i=0; i<50; i++) {
                    const d = document.createElement('div');
                    d.className = 'microtubule-unit';
                    if(Math.random()*100 < 60) d.classList.add('coherent');
                    el.appendChild(d);
                }
            }

            updateMetrics() {
                document.getElementById('consciousnessLevel').textContent = this.knowledgeGraph.evolution.toFixed(2);
                document.getElementById('problemsSolved').textContent = this.knowledgeGraph.history.length;
                document.getElementById('memorySize').textContent = Object.keys(this.knowledgeGraph.primes).length;
                document.getElementById('synapseCount').textContent = this.synapseCount;
            }

            logBreakthrough(msg) {
                const el = document.getElementById('breakthroughLog');
                const d = document.createElement('div');
                d.className = 'breakthrough-log';
                d.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}`;
                el.appendChild(d);
                el.scrollTop = el.scrollHeight;
            }

            triggerThoughtProcess(text) {
                document.getElementById('currentThought').textContent = text;
            }

            async computeHash(text) {
                const msg = new TextEncoder().encode(text);
                const buf = await crypto.subtle.digest('SHA-256', msg);
                return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
            }
        }

        const brain = new QuantumConsciousnessBrain();
    </script>
</body>
</html>