<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FRAYMUS TRANSMUTER // GEN 184</title>
    <style>
        /* --- AESTHETIC: COMPILER CORE --- */
        body { margin: 0; overflow: hidden; background: #080808; font-family: 'Consolas', monospace; color: #00FF00; display: flex; height: 100vh; }
        
        /* LAYOUT: SPLIT SCREEN */
        #input-panel, #output-panel {
            width: 300px; height: 100%; background: #050505; border-right: 1px solid #333;
            display: flex; flex-direction: column; padding: 10px; box-sizing: border-box; z-index: 10;
        }
        #output-panel { border-right: none; border-left: 1px solid #333; }
        
        #sim-container { flex-grow: 1; position: relative; background: #000; overflow: hidden; }
        
        textarea {
            flex-grow: 1; background: #111; border: 1px solid #333; color: #AAA; 
            font-family: inherit; font-size: 11px; padding: 10px; resize: none; outline: none;
        }
        textarea:focus { border-color: #00FF00; color: #FFF; }
        
        .header { font-weight: bold; margin-bottom: 10px; color: #00FF00; letter-spacing: 2px; }
        
        /* CONTROLS */
        #transmute-btn {
            background: #004400; color: #00FF00; border: 1px solid #00FF00; padding: 15px; 
            font-weight: bold; cursor: pointer; margin-top: 10px; text-transform: uppercase;
            transition: 0.2s; letter-spacing: 2px;
        }
        #transmute-btn:hover { background: #00FF00; color: #000; box-shadow: 0 0 20px #00FF00; }
        
        /* HUD OVERLAY */
        #hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none; width: 300px;
        }
        #progress-bar { width: 100%; height: 4px; background: #333; margin-top: 5px; }
        #progress-fill { width: 0%; height: 100%; background: #00FF00; box-shadow: 0 0 10px #00FF00; transition: width 0.1s; }
        
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>

    <div id="input-panel">
        <div class="header">RAW SOURCE</div>
        <textarea id="code-in" placeholder="// PASTE CODE HERE...
function messy() {
  var x=  1;
console.log('test');
}"></textarea>
        <button id="transmute-btn" onclick="startEvolution()">TRANSMUTE</button>
    </div>

    <div id="sim-container">
        <div id="hud">
            <div style="font-size:12px; color:#888;">OPTIMIZATION PROGRESS</div>
            <div id="progress-bar"><div id="progress-fill"></div></div>
            <div id="status-text" style="font-size:10px; margin-top:5px; color:#00FF00;">SYSTEM IDLE</div>
        </div>
        <canvas id="simCanvas"></canvas>
    </div>

    <div id="output-panel">
        <div class="header">EVOLVED CODE</div>
        <textarea id="code-out" readonly placeholder="AWAITING TRANSMUTATION..."></textarea>
    </div>

<script>
/**
 * ðŸ§¬ FRAYMUS TRANSMUTER // GEN 184
 * Visualizes code optimization as a particle physics simulation.
 */

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// --- STATE ---
let packets = []; // Code chunks
let agents = [];  // Optimizers
let particles = []; // FX
let evolution = 0;
let isRunning = false;
let sourceCode = "";

// --- CLASSES ---

class CodePacket {
    constructor(text, x, y) {
        this.text = text;
        this.pos = { x: x, y: y };
        this.vel = { x: (Math.random()-0.5)*2, y: (Math.random()-0.5)*2 };
        this.integrity = 0; // 0 to 100 (Optimized)
        this.color = "#555"; 
    }
    
    update() {
        this.pos.x += this.vel.x;
        this.pos.y += this.vel.y;
        
        // Bounce
        if(this.pos.x < 0 || this.pos.x > width) this.vel.x *= -1;
        if(this.pos.y < 0 || this.pos.y > height) this.vel.y *= -1;
        
        // Color shift based on integrity
        let g = Math.floor(this.integrity * 2.55);
        this.color = `rgb(0, ${g}, ${255-g})`;
    }
    
    draw() {
        ctx.fillStyle = this.color;
        ctx.font = "10px Consolas";
        ctx.fillText(this.text, this.pos.x, this.pos.y);
        
        // Integrity Bar
        ctx.fillStyle = "#333";
        ctx.fillRect(this.pos.x, this.pos.y+4, 20, 2);
        ctx.fillStyle = "#00FF00";
        ctx.fillRect(this.pos.x, this.pos.y+4, 20*(this.integrity/100), 2);
    }
}

class Agent {
    constructor(type) {
        this.type = type; // RED (Lint), GREEN (Opt), BLUE (Sec)
        this.pos = { x: Math.random()*width, y: Math.random()*height };
        this.vel = { x: (Math.random()-0.5)*4, y: (Math.random()-0.5)*4 };
        this.radius = 5;
    }
    
    getColor() {
        if(this.type === 'LINT') return '#FF0000';
        if(this.type === 'OPT') return '#00FF00';
        if(this.type === 'SEC') return '#0088FF';
    }
    
    update() {
        this.pos.x += this.vel.x;
        this.pos.y += this.vel.y;
        
        if(this.pos.x < 0 || this.pos.x > width) this.vel.x *= -1;
        if(this.pos.y < 0 || this.pos.y > height) this.vel.y *= -1;
        
        // Hunt Packets
        for(let p of packets) {
            let d = Math.sqrt((p.pos.x-this.pos.x)**2 + (p.pos.y-this.pos.y)**2);
            if(d < 30) {
                // Seek
                this.vel.x += (p.pos.x - this.pos.x) * 0.001;
                this.vel.y += (p.pos.y - this.pos.y) * 0.001;
                
                // Collision
                if(d < 10) {
                    p.integrity += 0.5;
                    evolution += 0.05;
                    createSpark(this.pos.x, this.pos.y, this.getColor());
                    // Bounce
                    this.vel.x *= -1; this.vel.y *= -1;
                }
            }
        }
        
        // Speed Limit
        let s = Math.sqrt(this.vel.x**2 + this.vel.y**2);
        if(s > 5) { this.vel.x*=0.9; this.vel.y*=0.9; }
    }
    
    draw() {
        ctx.beginPath();
        ctx.fillStyle = this.getColor();
        ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
        ctx.fill();
        // Glow
        ctx.shadowBlur = 10; ctx.shadowColor = this.getColor();
        ctx.stroke();
        ctx.shadowBlur = 0;
    }
}

function createSpark(x, y, col) {
    particles.push({x, y, col, life: 20});
}

// --- SYSTEM ---

function init() {
    resize();
    loop();
}

function startEvolution() {
    sourceCode = document.getElementById('code-in').value;
    if(!sourceCode) return;
    
    // Reset
    packets = [];
    agents = [];
    particles = [];
    evolution = 0;
    isRunning = true;
    document.getElementById('code-out').value = "EVOLVING...";
    document.getElementById('status-text').innerText = "INGESTING LOGIC...";
    document.getElementById('progress-fill').style.width = "0%";
    
    // 1. Atomize Code
    const lines = sourceCode.split('\n');
    lines.forEach((line, idx) => {
        if(line.trim().length > 0) {
            // Break line into tokens if long, or keep as chunk
            let x = width/2 + (Math.random()-0.5)*100;
            let y = height/2 + (Math.random()-0.5)*100;
            packets.push(new CodePacket(line.trim().substring(0, 15), x, y));
        }
    });
    
    // 2. Spawn Swarm
    for(let i=0; i<10; i++) agents.push(new Agent('LINT'));
    for(let i=0; i<10; i++) agents.push(new Agent('OPT'));
    for(let i=0; i<5; i++) agents.push(new Agent('SEC'));
}

function loop() {
    // Clear
    ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
    ctx.fillRect(0, 0, width, height);
    
    if(isRunning) {
        // Update Logic
        packets.forEach(p => { p.update(); p.draw(); });
        agents.forEach(a => { a.update(); a.draw(); });
        
        // Particles
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            ctx.fillStyle = p.col;
            ctx.fillRect(p.x, p.y, 2, 2);
            p.life--;
            if(p.life<=0) particles.splice(i,1);
        }
        
        // Check Progress
        let totalInt = packets.reduce((acc, p) => acc + p.integrity, 0);
        let maxInt = packets.length * 100;
        let progress = Math.min(100, (totalInt / maxInt) * 100);
        
        document.getElementById('progress-fill').style.width = progress + "%";
        
        if(progress >= 100) {
            completeEvolution();
        }
    }
    
    requestAnimationFrame(loop);
}

function completeEvolution() {
    isRunning = false;
    document.getElementById('status-text').innerText = "EVOLUTION COMPLETE";
    document.getElementById('status-text').style.color = "#00FF00";
    
    // 3. Reassemble (The "Mock" Optimization)
    // In a real app, this would be the LLM response. 
    // Here, we apply basic JS formatting logic.
    let cleanCode = sourceCode
        .split('\n')
        .map(l => l.trim())           // Remove excess whitespace
        .filter(l => l !== "")        // Remove empty lines
        .map(l => "  " + l)           // Add indent
        .join('\n');
        
    let header = "// [FRAYMUS GEN 184] OPTIMIZED BUILD\n// SAFETY: CHECKED\n// LOGIC: CONDENSED\n\n";
    let wrapper = "(function() {\n  'use strict';\n" + cleanCode + "\n})();";
    
    document.getElementById('code-out').value = header + wrapper;
    
    // Explosion FX
    for(let i=0; i<50; i++) createSpark(width/2, height/2, "#00FF00");
}

function resize() {
    width = document.getElementById('sim-container').clientWidth;
    height = document.getElementById('sim-container').clientHeight;
    canvas.width = width;
    canvas.height = height;
}
window.addEventListener('resize', resize);

init();

</script>
</body>
</html>
