<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FRAYMUS COMPLETE // GEN 180</title>
    <style>
        :root { --platinum: #E0E0E0; --obsidian: #050505; --amber: #FFB000; --cyan: #00F3FF; --danger: #FF0033; --glass: rgba(10, 10, 10, 0.9); }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; color: var(--platinum); user-select: none; }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        #header { height: 50px; background: var(--glass); border-bottom: 1px solid #333; display: flex; align-items: center; padding: 0 20px; justify-content: space-between; pointer-events: auto; transition: border-color 0.5s; }
        #header.threat-mode { border-bottom: 2px solid var(--danger); animation: pulse-border 2s infinite; }
        .logo { font-weight: bold; letter-spacing: 2px; color: #FFF; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        #date-display { font-size: 14px; color: var(--cyan); font-weight: bold; }
        #threat-level { font-size: 12px; padding: 5px 10px; border: 1px solid var(--cyan); color: var(--cyan); transition: all 0.3s; }
        #threat-level.critical { border-color: var(--danger); color: var(--danger); background: rgba(255, 0, 51, 0.1); animation: pulse 1s infinite; }

        #footer { height: 80px; background: var(--glass); border-top: 1px solid #333; display: flex; flex-direction: column; padding: 10px 20px; pointer-events: auto; gap: 10px; }
        .control-row { display: flex; gap: 10px; align-items: center; }
        .time-btn { background: transparent; border: 1px solid #555; color: #888; padding: 5px 15px; cursor: pointer; text-transform: uppercase; font-size: 10px; transition: 0.2s; }
        .time-btn:hover { border-color: var(--cyan); color: var(--cyan); }
        .time-btn.active { background: rgba(0, 243, 255, 0.2); border-color: var(--cyan); color: var(--cyan); }
        .time-btn.danger { border-color: #555; }
        .time-btn.danger:hover { border-color: var(--danger); color: var(--danger); box-shadow: 0 0 15px rgba(255, 0, 51, 0.3); }
        
        #time-slider-container { flex-grow: 1; height: 4px; background: #333; position: relative; cursor: ew-resize; }
        #time-slider-fill { height: 100%; background: var(--cyan); width: 50%; transition: width 0.1s; }
        #time-knob { width: 10px; height: 20px; background: #FFF; position: absolute; top: -8px; left: 50%; transform: translateX(-50%); box-shadow: 0 0 10px var(--cyan); cursor: grab; }

        .toggle-lbl { font-size: 10px; color: #888; display: flex; align-items: center; cursor: pointer; gap: 5px; }
        .toggle-lbl input { margin: 0; }

        #sidebar { position: absolute; top: 70px; right: 20px; width: 320px; background: var(--glass); border: 1px solid #333; padding: 15px; pointer-events: auto; max-height: 82vh; overflow-y: auto; transition: border-color 0.5s; }
        #sidebar.threat-mode { border-color: var(--danger); }
        .panel-header { color: var(--amber); border-bottom: 1px dashed #555; margin-bottom: 10px; font-size: 12px; letter-spacing: 1px; margin-top: 10px; }
        .data-row { display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 5px; }
        .label { color: #888; } .val { color: var(--cyan); font-weight: bold; }
        .val.danger { color: var(--danger); }

        #planet-nav { display: none; flex-wrap: wrap; gap: 5px; margin-top: 10px; }
        .planet-btn { flex: 1 0 22%; background: rgba(255,255,255,0.05); border: 1px solid #333; color: #AAA; padding: 5px; cursor: pointer; font-size: 9px; text-align: center; transition: 0.2s; }
        .planet-btn:hover { border-color: var(--platinum); color: #FFF; background: rgba(255,255,255,0.1); }
        
        #uap-warning { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; color: var(--danger); border: 4px solid var(--danger); padding: 20px; background: rgba(0,0,0,0.95); display: none; animation: flash 0.5s infinite; text-align: center; z-index: 1000; }
        
        #scanline { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(rgba(0,0,0,0) 50%, rgba(0, 0, 0, 0.2) 50%); background-size: 100% 4px; pointer-events: none; z-index: 99; }

        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        @keyframes pulse-border { 0% { border-color: var(--danger); } 50% { border-color: transparent; } 100% { border-color: var(--danger); } }
        @keyframes flash { 0% { border-color: transparent; } 50% { border-color: var(--danger); } 100% { border-color: transparent; } }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
</head>
<body>

    <div id="uap-warning">
        ‚ö†Ô∏è UAP DETECTED ‚ö†Ô∏è<br>
        <span style="font-size:16px;">NON-BALLISTIC TRAJECTORY CONFIRMED</span>
    </div>

    <div id="ui-layer">
        <div id="header">
            <span class="logo">FRAYMUS COMPLETE // œÜ-GRAVITY + THREATS</span>
            <div style="display: flex; gap: 20px; align-items: center;">
                <div id="threat-level">DEFCON 5: MONITORING</div>
                <div id="date-display">2026-02-11 21:40:00</div>
            </div>
        </div>

        <div id="sidebar">
            <div class="panel-header">QUANTUM TELEMETRY</div>
            <div id="telemetry">
                <div class="data-row"><span class="label">TARGET:</span> <span class="val" id="target-name">EARTH</span></div>
                <div class="data-row"><span class="label">DIST (SUN):</span> <span class="val" id="target-dist">1.00 AU</span></div>
                <div class="data-row"><span class="label">VELOCITY:</span> <span class="val" id="target-vel">29.78 km/s</span></div>
                <div class="data-row"><span class="label">œÜ-FORCE:</span> <span class="val" id="target-phi">1.618 N</span></div>
                <div class="data-row"><span class="label">MAGNETIC:</span> <span class="val" id="target-mag">0.42 ŒºT</span></div>
                <div class="data-row"><span class="label">DARK MATTER:</span> <span class="val" id="target-dm">23.7%</span></div>
                <div class="data-row"><span class="label">ROTATION:</span> <span class="val" id="target-rot">24.0 hrs</span></div>
            </div>
            
            <div class="panel-header">THREAT ASSESSMENT</div>
            <div id="threat-data">
                <div class="data-row"><span class="label">NEOs TRACKED:</span> <span class="val" id="neo-count">4</span></div>
                <div class="data-row"><span class="label">COLLISION PROB:</span> <span class="val" id="col-prob">0.04%</span></div>
                <div class="data-row"><span class="label">UAP SIGHTINGS:</span> <span class="val" id="uap-count">0</span></div>
                <div class="data-row"><span class="label">CLOSEST APPROACH:</span> <span class="val" id="closest">N/A</span></div>
            </div>
            
            <div class="panel-header">NAVIGATION</div>
            <div style="display:flex; flex-wrap:wrap; gap:5px;">
                <button class="time-btn" onclick="focusBody('SUN')">SUN</button>
                <button class="time-btn" onclick="focusBody('MERCURY')">MERCURY</button>
                <button class="time-btn" onclick="focusBody('VENUS')">VENUS</button>
                <button class="time-btn" onclick="focusBody('EARTH')">EARTH</button>
                <button class="time-btn" onclick="focusBody('MARS')">MARS</button>
                <button class="time-btn" onclick="focusBody('JUPITER')">JUPITER</button>
                <button class="time-btn" onclick="focusBody('SATURN')">SATURN</button>
                <button class="time-btn" onclick="focusBody('URANUS')">URANUS</button>
                <button class="time-btn" onclick="focusBody('NEPTUNE')">NEPTUNE</button>
            </div>
            
            <div class="panel-header">QUANTUM LAYERS</div>
            <label class="toggle-lbl"><input type="checkbox" id="chk-mag" checked onchange="toggleLayer('magnetic')"> MAGNETIC FIELDS</label>
            <label class="toggle-lbl"><input type="checkbox" id="chk-dm" checked onchange="toggleLayer('darkmatter')"> DARK MATTER HALO</label>
            <label class="toggle-lbl"><input type="checkbox" id="chk-ast" checked onchange="toggleLayer('asteroids')"> ASTEROID BELT</label>
            <label class="toggle-lbl"><input type="checkbox" id="chk-prob" checked onchange="toggleLayer('probability')"> PROBABILITY CLOUDS</label>
        </div>

        <div id="footer">
            <div class="control-row">
                <button class="time-btn" onclick="setTimeSpeed(-1000)"><< REV</button>
                <button class="time-btn" onclick="setTimeSpeed(-100)">< REV</button>
                <button class="time-btn" onclick="setTimeSpeed(0)">PAUSE</button>
                <button class="time-btn active" id="btn-now" onclick="setTimeSpeed(1); setRealTime()">NOW</button>
                <button class="time-btn" onclick="setTimeSpeed(100)">FWD ></button>
                <button class="time-btn" onclick="setTimeSpeed(1000)">WARP >></button>
                
                <div id="time-slider-container" onmousedown="startDrag(event)">
                    <div id="time-slider-fill"></div>
                    <div id="time-knob"></div>
                </div>
            </div>
            <div class="control-row">
                <button class="time-btn danger" onclick="toggleDarkSector()">DARK SECTOR</button>
                <button class="time-btn danger" onclick="spawnUAP()">TRIGGER UAP</button>
                <button class="time-btn" onclick="toggleLayer('ngrok')">NGROK FIELD</button>
            </div>
        </div>
    </div>

    <div id="scanline"></div>

<script>
/**
 * üß¨ FRAYMUS COMPLETE // GEN 180
 * Beauty + Danger: Quantum Physics + Threat Detection
 */

// --- CONSTANTS ---
const PHI = 1.6180339887;
const PI = Math.PI;
const G_PHI = 6.674e-11 * PHI;

// --- GLOBAL STATE ---
let scene, camera, renderer, controls, composer;
let simTime = new Date();
let timeSpeed = 1;
let targetBody = 'EARTH';
let bodies = {};
let asteroidBelt = null;
let darkMatterHalo = null;
let magneticFields = [];
let probabilityClouds = [];
let neoAsteroids = [];
let uaps = [];
let ngrokField = null;
let isDragging = false;
let isDarkSector = false;

// Toggles
let showMagnetic = true;
let showDarkMatter = true;
let showAsteroids = true;
let showProbability = true;
let showNgrok = false;

const TIME_START = new Date('1900-01-01T00:00:00Z');
const TIME_END = new Date('2100-12-31T23:59:59Z');
const TIME_RANGE = TIME_END - TIME_START;

// ENHANCED ORBITAL DATA
const ORBITS = {
    MERCURY: { a:0.387, e:0.2056, i:7.00, L:252.25, w:77.46, n:4.092, color:0xA5A5A5, radius:0.5, rotSpeed:0.0005, magField:0.003, dmInfluence:0.15 },
    VENUS:   { a:0.723, e:0.0068, i:3.39, L:181.98, w:131.53, n:1.602, color:0xE3BB76, radius:0.7, rotSpeed:-0.001, magField:0.0, dmInfluence:0.18 },
    EARTH:   { a:1.000, e:0.0167, i:0.00, L:100.46, w:102.94, n:0.9856, color:0x00A2FF, radius:0.8, rotSpeed:0.02, magField:0.5, dmInfluence:0.237 },
    MARS:    { a:1.524, e:0.0934, i:1.85, L:355.45, w:336.04, n:0.524, color:0xFF4500, radius:0.6, rotSpeed:0.019, magField:0.0, dmInfluence:0.21 },
    JUPITER: { a:5.203, e:0.0484, i:1.30, L:34.40,  w:14.75,  n:0.083, color:0xD9A07E, radius:2.5, rotSpeed:0.05, magField:4.28, dmInfluence:0.31 },
    SATURN:  { a:9.537, e:0.0541, i:2.48, L:49.94,  w:92.43,  n:0.033, color:0xF4D03F, radius:2.2, rotSpeed:0.045, magField:0.58, dmInfluence:0.28 },
    URANUS:  { a:19.19, e:0.0471, i:0.77, L:313.23, w:170.96, n:0.011, color:0xD1F5F0, radius:1.5, rotSpeed:-0.03, magField:0.23, dmInfluence:0.25 },
    NEPTUNE: { a:30.07, e:0.0086, i:1.77, L:304.88, w:44.97,  n:0.006, color:0x2E5D94, radius:1.5, rotSpeed:0.032, magField:0.14, dmInfluence:0.26 }
};

// NEO THREATS
const NEOs = [
    { name: "APOPHIS", a: 0.92, e: 0.19, i: 3.3, n: 3.8, L: 100, w: 126, color: 0xFF0000, size: 1.5 },
    { name: "BENNU", a: 1.12, e: 0.20, i: 6.0, n: 2.9, L: 200, w: 66, color: 0xFF3300, size: 1.2 },
    { name: "CERES", a: 2.77, e: 0.07, i: 10.6, n: 0.35, L: 80, w: 73, color: 0x888888, size: 2.0 },
    { name: "VESTA", a: 2.36, e: 0.08, i: 7.1, n: 0.42, L: 150, w: 103, color: 0xAAAAAA, size: 1.8 }
];

// --- INIT ---
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x000000, 0.0002);
    
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 10000);
    camera.position.set(0, 80, 150);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Post-processing
    const renderScene = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0;
    bloomPass.strength = 1.2;
    bloomPass.radius = 0.5;
    composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    addStarfield();
    createDarkMatterHalo();
    
    // Sun
    const sunGeo = new THREE.SphereGeometry(5, 32, 32);
    const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
    const sun = new THREE.Mesh(sunGeo, sunMat);
    scene.add(sun);
    
    const glowGeo = new THREE.SphereGeometry(7, 32, 32);
    const glowMat = new THREE.MeshBasicMaterial({ color: 0xFFAA00, transparent: true, opacity: 0.3 });
    const glow = new THREE.Mesh(glowGeo, glowMat);
    scene.add(glow);
    
    bodies['SUN'] = { mesh: sun, glow: glow, data: null };
    
    const light = new THREE.PointLight(0xFFFFFF, 2, 2000);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x222222));

    Object.keys(ORBITS).forEach(name => createPlanet(name, ORBITS[name]));
    createAsteroidBelt();
    createNEOs();
    createNgrokField();
    
    focusBody('EARTH');
    animate();
}

function createPlanet(name, data) {
    const geo = new THREE.SphereGeometry(data.radius, 32, 32);
    const mat = new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.7 });
    const mesh = new THREE.Mesh(geo, mat);
    scene.add(mesh);
    
    // Orbit Path
    const pts = [];
    for(let i=0; i<=360; i++) {
        const angle = i * (PI/180);
        const r = data.a * (1 - data.e*data.e) / (1 + data.e * Math.cos(angle));
        const x = r * Math.cos(angle) * 50;
        const z = r * Math.sin(angle) * 50;
        pts.push(new THREE.Vector3(x, 0, z));
    }
    const pathGeo = new THREE.BufferGeometry().setFromPoints(pts);
    const pathMat = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.5 });
    const path = new THREE.Line(pathGeo, pathMat);
    scene.add(path);

    // Magnetic Field
    let magField = null;
    if(data.magField > 0.1) {
        magField = createMagneticField(data.radius, data.magField);
        mesh.add(magField);
        magneticFields.push(magField);
    }

    // Probability Cloud
    const probCloud = createProbabilityCloud(data.radius);
    mesh.add(probCloud);
    probabilityClouds.push(probCloud);

    bodies[name] = { 
        mesh: mesh, 
        data: data, 
        path: path,
        magField: magField,
        probCloud: probCloud,
        rotation: 0
    };
}

function createMagneticField(radius, strength) {
    const group = new THREE.Group();
    const fieldColor = 0x00FFFF;
    
    for(let i=0; i<8; i++) {
        const angle = (i / 8) * PI * 2;
        const pts = [];
        for(let t=0; t<=1; t+=0.05) {
            const r = radius * (1.5 + t * 2 * strength);
            const theta = angle;
            const phi = PI/2 - t * PI;
            pts.push(new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            ));
        }
        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        const mat = new THREE.LineBasicMaterial({ color: fieldColor, transparent: true, opacity: 0.3 });
        const line = new THREE.Line(geo, mat);
        group.add(line);
    }
    
    return group;
}

function createProbabilityCloud(radius) {
    const geo = new THREE.SphereGeometry(radius * 1.2, 16, 16);
    const mat = new THREE.MeshBasicMaterial({ 
        color: 0xFFFFFF, 
        transparent: true, 
        opacity: 0.05,
        wireframe: true,
        blending: THREE.AdditiveBlending
    });
    return new THREE.Mesh(geo, mat);
}

function createAsteroidBelt() {
    const count = 3000;
    const geo = new THREE.BufferGeometry();
    const pos = [];
    const colors = [];
    
    for(let i=0; i<count; i++) {
        const r = (2.2 + Math.random() * 1.5) * 50;
        const theta = Math.random() * PI * 2;
        const y = (Math.random() - 0.5) * 5;
        
        pos.push(
            r * Math.cos(theta),
            y,
            r * Math.sin(theta)
        );
        
        const c = 0.5 + Math.random() * 0.3;
        colors.push(c, c*0.8, c*0.6);
    }
    
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    
    const mat = new THREE.PointsMaterial({ 
        vertexColors: true, 
        size: 0.5, 
        transparent: true, 
        opacity: 0.6 
    });
    
    asteroidBelt = new THREE.Points(geo, mat);
    scene.add(asteroidBelt);
}

function createNEOs() {
    NEOs.forEach(n => {
        const geo = new THREE.DodecahedronGeometry(n.size, 0);
        const mat = new THREE.MeshBasicMaterial({ color: n.color, wireframe: true });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.visible = false;
        scene.add(mesh);
        
        // Threat path
        const pts = [];
        for(let i=0; i<=64; i++) {
            const theta = (i/64) * PI * 2;
            const r = n.a * 50;
            const y = Math.sin(theta * 2) * (n.i * 2);
            pts.push(r * Math.cos(theta), y, r * Math.sin(theta));
        }
        const pathGeo = new THREE.BufferGeometry().setFromPoints(pts);
        const path = new THREE.Line(pathGeo, new THREE.LineBasicMaterial({ color: 0x550000, transparent: true, opacity: 0.5 }));
        path.visible = false;
        scene.add(path);
        
        neoAsteroids.push({ mesh: mesh, path: path, data: n, angle: Math.random() * PI });
    });
}

function createDarkMatterHalo() {
    const count = 5000;
    const geo = new THREE.BufferGeometry();
    const pos = [];
    const colors = [];
    
    for(let i=0; i<count; i++) {
        const r = 100 + Math.random() * 400;
        const theta = Math.random() * PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        pos.push(
            r * Math.sin(phi) * Math.cos(theta),
            r * Math.sin(phi) * Math.sin(theta),
            r * Math.cos(phi)
        );
        
        colors.push(0.3, 0.1, 0.5);
    }
    
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    
    const mat = new THREE.PointsMaterial({ 
        vertexColors: true, 
        size: 2, 
        transparent: true, 
        opacity: 0.2,
        blending: THREE.AdditiveBlending
    });
    
    darkMatterHalo = new THREE.Points(geo, mat);
    scene.add(darkMatterHalo);
}

function createNgrokField() {
    const geo = new THREE.WireframeGeometry(new THREE.IcosahedronGeometry(600, 2));
    const mat = new THREE.LineBasicMaterial({color:0x330033, transparent:true, opacity:0.1});
    ngrokField = new THREE.LineSegments(geo, mat);
    ngrokField.visible = false;
    scene.add(ngrokField);
}

function addStarfield() {
    const geo = new THREE.BufferGeometry();
    const pos = [];
    const colors = [];
    const c1 = new THREE.Color(0x88ccff);
    const c2 = new THREE.Color(0xffbb88);
    
    for(let i=0; i<8000; i++) {
        pos.push((Math.random()-0.5)*3000, (Math.random()-0.5)*3000, (Math.random()-0.5)*3000);
        const c = Math.random() > 0.5 ? c1 : c2;
        colors.push(c.r, c.g, c.b);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    const mat = new THREE.PointsMaterial({vertexColors: true, size: 1.5, transparent: true, opacity: 0.8});
    scene.add(new THREE.Points(geo, mat));
}

// --- œÜ-GRAVITY CALCULATION ---
function calculatePosition(data, daysSinceJ2000) {
    let M = data.n * daysSinceJ2000 + data.L - data.w;
    M = M % 360; if(M<0) M+=360;
    
    let E = M;
    for(let iter=0; iter<5; iter++) {
        E = M + (180/PI) * data.e * Math.sin(E * PI/180);
    }
    
    const radE = E * (PI/180);
    const v = 2 * Math.atan2(
        Math.sqrt(1 + data.e) * Math.sin(radE/2),
        Math.sqrt(1 - data.e) * Math.cos(radE/2)
    ) * (180/PI);
                
    const radv = v * (PI/180);
    const r_base = data.a * (1 - data.e*data.e) / (1 + data.e * Math.cos(radv));
    const r = r_base * (1 + data.dmInfluence * Math.sin(daysSinceJ2000 / 100) * 0.01);
    
    const radL = (v + data.w) * (PI/180);
    const x = r * Math.cos(radL);
    const z = r * Math.sin(radL);
    
    const uncertainty = showProbability ? (Math.random() - 0.5) * 0.01 : 0;
    
    return { 
        x: (x + uncertainty) * 50, 
        z: (z + uncertainty) * 50, 
        r: r 
    };
}

// --- UAP SYSTEM ---
function spawnUAP() {
    const geo = new THREE.ConeGeometry(2, 5, 4);
    const mat = new THREE.MeshBasicMaterial({color:0xFFFFFF});
    const mesh = new THREE.Mesh(geo, mat);
    scene.add(mesh);

    uaps.push({
        mesh:mesh,
        t:0,
        origin: new THREE.Vector3((Math.random()-0.5)*800, (Math.random()-0.5)*200, (Math.random()-0.5)*800)
    });

    const alert = document.getElementById('uap-warning');
    alert.style.display = 'block';
    document.getElementById('threat-level').innerText = "DEFCON 1: INTERCEPT";
    document.getElementById('threat-level').classList.add('critical');
    setTimeout(() => { alert.style.display = 'none'; }, 3000);

    document.getElementById('uap-count').innerText = uaps.length;
}

function updateUAPs() {
    for(let i=uaps.length-1; i>=0; i--) {
        const u = uaps[i];
        u.t += 0.02;

        u.mesh.position.x = u.origin.x + Math.sin(u.t * 5) * 100 + (u.t * 50);
        u.mesh.position.y = u.origin.y + Math.cos(u.t * 13) * 50;
        u.mesh.position.z = u.origin.z + Math.sin(u.t * 3) * 100;

        u.mesh.rotation.x += 0.1;
        u.mesh.rotation.z += 0.1;

        if(u.t > 10) {
            scene.remove(u.mesh);
            uaps.splice(i, 1);
            if(uaps.length === 0) {
                document.getElementById('threat-level').innerText = "DEFCON 5: MONITORING";
                document.getElementById('threat-level').classList.remove('critical');
            }
        }
    }
    document.getElementById('uap-count').innerText = uaps.length;
}

// --- COLLISION DETECTION ---
function checkCollisions() {
    if(!isDarkSector || !bodies['EARTH']) return;
    
    const earth = bodies['EARTH'].mesh.position;
    let minDist = Infinity;
    let closestNEO = null;
    
    neoAsteroids.forEach(a => {
        const dist = a.mesh.position.distanceTo(earth);
        if(dist < minDist) {
            minDist = dist;
            closestNEO = a.data.name;
        }
        
        if(dist < 20) {
            document.getElementById('col-prob').innerText = "CRITICAL (99.9%)";
            document.getElementById('col-prob').classList.add('danger');
            document.getElementById('threat-level').innerText = "DEFCON 1: IMPACT IMMINENT";
            document.getElementById('threat-level').classList.add('critical');
        }
    });
    
    if(minDist < Infinity) {
        document.getElementById('closest').innerText = `${closestNEO} (${(minDist/50).toFixed(2)} AU)`;
    }
    
    if(minDist > 20) {
        document.getElementById('col-prob').innerText = "0.04%";
        document.getElementById('col-prob').classList.remove('danger');
    }
}

// --- DARK SECTOR TOGGLE ---
function toggleDarkSector() {
    isDarkSector = !isDarkSector;
    
    neoAsteroids.forEach(a => {
        a.mesh.visible = isDarkSector;
        a.path.visible = isDarkSector;
    });
    
    document.getElementById('header').classList.toggle('threat-mode', isDarkSector);
    document.getElementById('sidebar').classList.toggle('threat-mode', isDarkSector);
    
    if(isDarkSector) {
        scene.background = new THREE.Color(0x110000);
        scene.fog = new THREE.FogExp2(0x110000, 0.0005);
    } else {
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.0002);
        document.getElementById('threat-level').innerText = "DEFCON 5: MONITORING";
        document.getElementById('threat-level').classList.remove('critical');
        document.getElementById('col-prob').innerText = "0.04%";
        document.getElementById('col-prob').classList.remove('danger');
    }
}

// --- ANIMATION LOOP ---
function animate() {
    requestAnimationFrame(animate);
    controls.update();
    
    if(timeSpeed !== 0 && !isDragging) {
        simTime.setSeconds(simTime.getSeconds() + timeSpeed);
        updateSlider();
    }
    
    updateDateDisplay();
    
    const j2000 = new Date('2000-01-01T12:00:00Z');
    const days = (simTime - j2000) / (1000 * 60 * 60 * 24);

    // Update Planets
    Object.keys(bodies).forEach(name => {
        if(name === 'SUN') return;
        const b = bodies[name];
        const pos = calculatePosition(b.data, days);
        b.mesh.position.set(pos.x, 0, pos.z);
        
        b.rotation += b.data.rotSpeed;
        b.mesh.rotation.y = b.rotation;
        
        if(name === targetBody) {
            document.getElementById('target-dist').innerText = pos.r.toFixed(3) + ' AU';
            const period = 365.25 / b.data.n;
            const vel = (2 * PI * b.data.a * 149.6e6) / (period * 86400);
            document.getElementById('target-vel').innerText = vel.toFixed(2) + ' km/s';
            document.getElementById('target-phi').innerText = (PHI * b.data.a).toFixed(3) + ' N';
            document.getElementById('target-mag').innerText = b.data.magField.toFixed(2) + ' ŒºT';
            document.getElementById('target-dm').innerText = (b.data.dmInfluence * 100).toFixed(1) + '%';
            document.getElementById('target-rot').innerText = (24 / b.data.rotSpeed).toFixed(1) + ' hrs';
        }
    });

    // Update NEOs
    if(isDarkSector) {
        neoAsteroids.forEach(a => {
            a.angle += a.data.n * 0.002;
            const pos = calculatePosition(a.data, days);
            a.mesh.position.set(pos.x, Math.sin(a.angle * 2) * (a.data.i * 2), pos.z);
            a.mesh.rotation.x += 0.01;
        });
        checkCollisions();
    }

    if(asteroidBelt) asteroidBelt.rotation.y += 0.0001;
    
    if(darkMatterHalo) {
        darkMatterHalo.rotation.y += 0.0002;
        darkMatterHalo.material.opacity = 0.15 + Math.sin(Date.now() * 0.001) * 0.05;
    }
    
    if(showNgrok && ngrokField) {
        ngrokField.rotation.y += 0.001;
        ngrokField.rotation.z -= 0.0005;
        ngrokField.scale.setScalar(1 + Math.sin(Date.now() * 0.01) * 0.05);
    }

    updateUAPs();

    if(targetBody && bodies[targetBody]) {
        const p = bodies[targetBody].mesh.position;
        controls.target.lerp(p, 0.05);
    }
    
    composer.render();
}

function toggleLayer(layer) {
    if(layer === 'magnetic') {
        showMagnetic = !showMagnetic;
        magneticFields.forEach(f => { if(f) f.visible = showMagnetic; });
    } else if(layer === 'darkmatter') {
        showDarkMatter = !showDarkMatter;
        if(darkMatterHalo) darkMatterHalo.visible = showDarkMatter;
    } else if(layer === 'asteroids') {
        showAsteroids = !showAsteroids;
        if(asteroidBelt) asteroidBelt.visible = showAsteroids;
    } else if(layer === 'probability') {
        showProbability = !showProbability;
        probabilityClouds.forEach(c => { if(c) c.visible = showProbability; });
    } else if(layer === 'ngrok') {
        showNgrok = !showNgrok;
        if(ngrokField) ngrokField.visible = showNgrok;
    }
}

function updateDateDisplay() {
    document.getElementById('date-display').innerText = simTime.toISOString().replace('T', ' ').split('.')[0];
}

function updateSlider() {
    const progress = (simTime - TIME_START) / TIME_RANGE;
    const percent = Math.max(0, Math.min(100, progress * 100));
    document.getElementById('time-slider-fill').style.width = percent + '%';
    document.getElementById('time-knob').style.left = percent + '%';
}

function focusBody(name) {
    targetBody = name;
    document.getElementById('target-name').innerText = name;
    if(name === 'SUN') {
        controls.target.set(0, 0, 0);
        camera.position.set(0, 80, 150);
    }
}

function setRealTime() {
    simTime = new Date();
    updateSlider();
    updateActiveButton('btn-now');
}

function setTimeSpeed(speed) {
    timeSpeed = speed;
    updateActiveButton(null);
}

function updateActiveButton(id) {
    document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
    if(id) document.getElementById(id).classList.add('active');
}

function startDrag(e) {
    isDragging = true;
    updateTimeFromMouse(e);
    
    function onMove(e) {
        if(isDragging) updateTimeFromMouse(e);
    }
    
    function onUp() {
        isDragging = false;
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
    }
    
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
}

function updateTimeFromMouse(e) {
    const slider = document.getElementById('time-slider-container');
    const rect = slider.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const percent = Math.max(0, Math.min(1, x / rect.width));
    
    simTime = new Date(TIME_START.getTime() + percent * TIME_RANGE);
    updateSlider();
    timeSpeed = 0;
    updateActiveButton(null);
}

window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    composer.setSize(window.innerWidth, window.innerHeight);
});

init();

</script>
</body>
</html>
